<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils_kinematics.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils_kinematics.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {
    exp_se3_to_SE3,
    exp_so3_and_v_to_SO3_and_t,
    exp_so3_to_SO3, ln_SO3_and_t_to_so3_and_v, so3_mat_to_vec3,
    vec3_to_so3_mat,
    vec6_to_se3_mat
} from "./utils_exp_and_log_obfuscated.js";
import {
    add_matrix_matrix, dot_product, frobenius_norm_matrix, identity_matrix,
    mul_matrix_matrix,
    mul_matrix_scalar,
    normalized_matrix, pt_dis_to_line, sub_matrix_matrix,
    unroll_matrix_to_list
} from "./utils_math.js";
import {get_default_lil_gui, refresh_displays} from "./utils_three.js";
import {
    displacement_pose_SO3_and_position,
    interpolate_poses_SO3_and_position,
    map_pose_SO3_and_position
} from "./utils_exp_and_log_obfuscated.js";
import {
    optimization_bfgs,
    optimization_gradient_descent,
    optimization_powell,
    optimization_solve
} from "./utils_optimization.js";
import {TransformGizmoEngine} from "./utils_transform_gizmo.js";
import {
    get_bounding_sphere_radius,
    get_bounding_sphere_offset,
    draw_obb,
    draw_bounding_sphere,
    draw_decomposed_obb,
    draw_decomposed_bounding_sphere,
} from "./utils_visualize_bounding_volumes.js";

/**
 * Computes the forward kinematics for a robot given its state.
 * @param {Object} robot - The robot object containing its links and joints.
 * @param {Array&lt;number>} state - The state of the robot's joints.
 * @returns {Array&lt;Array&lt;Array&lt;number>>>} - An array of SE3 transformation matrices for each link.
 */
export function forward_kinematics_SE3(robot, state) {
    let num_links = robot.num_links();

    let out = [];
    for(let i = 0; i &lt; num_links; i++) {
        out.push(exp_se3_to_SE3(vec6_to_se3_mat([0,0,0,0,0,0])));
    }

    let kinematic_hierarchy = robot.kinematic_hierarchy;

    for(let i = 1; i &lt; kinematic_hierarchy.length; i++) {
        let layer = kinematic_hierarchy[i];
        layer.forEach(link_idx => {
            let link = robot.links[link_idx];
            let parent_joint_idx = link.parent_joint_idx;
            let parent_link_idx = link.parent_link_idx;
            let joint = robot.joints[parent_joint_idx];

            let joint_type_string = joint.joint_type_string;

            let parent_pose = out[parent_link_idx];

            let constant_transform = joint.xyz_rpy_SE3_matrix;

            let curr_pose = mul_matrix_matrix(parent_pose, constant_transform);

            if(joint_type_string === 'prismatic') {
                let joint_value = state[joint.dof_idx];

                let variable_transform = [
                    [1, 0, 0, joint_value*joint.axis[0][0]],
                    [0, 1, 0, joint_value*joint.axis[1][0]],
                    [0, 0, 1, joint_value*joint.axis[2][0]],
                    [0, 0, 0, 1]
                ];

                curr_pose = mul_matrix_matrix(curr_pose, variable_transform);

            } else if(joint_type_string === 'revolute') {
                let joint_value = state[joint.dof_idx];

                let u = joint.axis;
                let un = normalized_matrix(u);
                let us = mul_matrix_scalar(un, joint_value);
                us = unroll_matrix_to_list(us);
                let se3_mat = vec6_to_se3_mat([us[0], us[1], us[2], 0, 0, 0]);
                let variable_transform = exp_se3_to_SE3(se3_mat);

                curr_pose = mul_matrix_matrix(curr_pose, variable_transform);
            } else if(joint_type_string === 'floating') {
                let rd = joint.rotation_dof_idxs;
                let td = joint.translation_dof_idxs;

                let rv = [ state[rd[0]], state[rd[1]], state[rd[2]] ];
                let tv = [ state[td[0]], state[td[1]], state[td[2]] ];

                let so3_mat = vec3_to_so3_mat(rv);
                let R = exp_so3_to_SO3(so3_mat);

                let variable_transform = [
                    [ R[0][0], R[0][1], R[0][2], tv[0] ],
                    [ R[1][0], R[1][1], R[1][2], tv[1] ],
                    [ R[2][0], R[2][1], R[2][2], tv[2] ],
                    [ 0, 0, 0, 1 ]
                ];

                curr_pose = mul_matrix_matrix(curr_pose, variable_transform);
            }

            out[link_idx] = curr_pose;
        });
    }


    return out;
}

/**
 * Computes the forward kinematics for a robot using SO3 matrices and positions.
 * @param {Object} robot - The robot object containing its links and joints.
 * @param {Array&lt;number>} state - The state of the robot's joints.
 * @returns {Array&lt;Array>} - An array of SO3 matrices and positions for each link.
 */
export function forward_kinematics_SO3_and_position(robot, state) {
    let num_links = robot.num_links();

    let out = [];
    for(let i = 0; i &lt; num_links; i++) {
        out.push(exp_so3_and_v_to_SO3_and_t(vec3_to_so3_mat([0,0,0]), [0,0,0]));
    }

    let kinematic_hierarchy = robot.kinematic_hierarchy;

    for(let i = 1; i &lt; kinematic_hierarchy.length; i++) {
        let layer = kinematic_hierarchy[i];
        layer.forEach(link_idx => {
            let link = robot.links[link_idx];
            let parent_joint_idx = link.parent_joint_idx;
            let parent_link_idx = link.parent_link_idx;
            let joint = robot.joints[parent_joint_idx];

            let joint_type_string = joint.joint_type_string;

            let parent_pose = out[parent_link_idx];

            let constant_transform = [joint.rpy_SO3_matrix, joint.xyz_vec];

            // let curr_pose = mul_matrix_matrix(parent_pose, constant_transform);
            let curr_pose = [ mul_matrix_matrix(parent_pose[0], constant_transform[0]), add_matrix_matrix( mul_matrix_matrix(parent_pose[0], constant_transform[1]), parent_pose[1] ) ];

            if(joint_type_string === 'prismatic') {
                let joint_value = state[joint.dof_idx];

                let variable_transform = [ identity_matrix(3), [ [joint_value*joint.axis[0][0]], [joint_value*joint.axis[1][0]], [joint_value*joint.axis[2][0]] ] ];
                // curr_pose = mul_matrix_matrix(curr_pose, variable_transform);
                curr_pose = [ mul_matrix_matrix(curr_pose[0], variable_transform[0]), add_matrix_matrix( mul_matrix_matrix(curr_pose[0], variable_transform[1]), curr_pose[1] ) ];
            } else if(joint_type_string === 'revolute') {
                let joint_value = state[joint.dof_idx];

                let u = joint.axis;
                let un = normalized_matrix(u);
                let us = mul_matrix_scalar(un, joint_value);
                us = unroll_matrix_to_list(us);
                // let se3_mat = vec6_to_se3_mat([us[0], us[1], us[2], 0, 0, 0]);
                // let variable_transform = exp_se3_to_SE3(se3_mat);
                let so3_mat = vec3_to_so3_mat(us);
                let SO3_mat = exp_so3_to_SO3(so3_mat);
                let variable_transform = [ SO3_mat, [[0], [0], [0]] ];

                // curr_pose = mul_matrix_matrix(curr_pose, variable_transform);
                curr_pose = [ mul_matrix_matrix(curr_pose[0], variable_transform[0]), add_matrix_matrix( mul_matrix_matrix(curr_pose[0], variable_transform[1]), curr_pose[1] ) ];

            } else if(joint_type_string === 'floating') {
                let rd = joint.rotation_dof_idxs;
                let td = joint.translation_dof_idxs;

                let rv = [ state[rd[0]], state[rd[1]], state[rd[2]] ];
                let tv = [ state[td[0]], state[td[1]], state[td[2]] ];

                let so3_mat = vec3_to_so3_mat(rv);
                let R = exp_so3_to_SO3(so3_mat);

                // let variable_transform = [
                //     [ R[0][0], R[0][1], R[0][2], tv[0] ],
                //     [ R[1][0], R[1][1], R[1][2], tv[1] ],
                //     [ R[2][0], R[2][1], R[2][2], tv[2] ],
                //     [ 0, 0, 0, 1 ]
                // ];
                let variable_transform = [ R, [ [tv[0]], [tv[1]], [tv[2]] ] ];

                // curr_pose = mul_matrix_matrix(curr_pose, variable_transform);
                curr_pose = [ mul_matrix_matrix(curr_pose[0], variable_transform[0]), add_matrix_matrix( mul_matrix_matrix(curr_pose[0], variable_transform[1]), curr_pose[1] ) ];
            }

            // console.log(curr_pose);
            out[link_idx] = curr_pose;
        });
    }

    return out;
}

/**
 * Computes forward kinematics for a robot and returns all intermediate poses.
 * @param {Object} robot - The robot object containing its links and joints.
 * @param {Array&lt;number>} state - The state of the robot's joints.
 * @returns {Array&lt;Array&lt;Array>>} - An array of poses at each stage for each link.
 */
export function forward_kinematics_SO3_and_position_all(robot, state) {
    let num_links = robot.num_links();

    let out1 = [];
    let out2 = [];
    let out3 = [];
    for(let i = 0; i &lt; num_links; i++) {
        out1.push(exp_so3_and_v_to_SO3_and_t(vec3_to_so3_mat([0,0,0]), [0,0,0]));
        out2.push(exp_so3_and_v_to_SO3_and_t(vec3_to_so3_mat([0,0,0]), [0,0,0]));
        out3.push(exp_so3_and_v_to_SO3_and_t(vec3_to_so3_mat([0,0,0]), [0,0,0]));
    }

    let kinematic_hierarchy = robot.kinematic_hierarchy;

    for(let i = 1; i &lt; kinematic_hierarchy.length; i++) {
        let layer = kinematic_hierarchy[i];
        layer.forEach(link_idx => {
            let link = robot.links[link_idx];
            let parent_joint_idx = link.parent_joint_idx;
            let parent_link_idx = link.parent_link_idx;
            let joint = robot.joints[parent_joint_idx];

            let joint_type_string = joint.joint_type_string;

            let parent_pose = out3[parent_link_idx];
            out1[link_idx] = parent_pose.slice();

            let constant_transform = [joint.rpy_SO3_matrix, joint.xyz_vec];

            // let curr_pose = mul_matrix_matrix(parent_pose, constant_transform);
            let curr_pose = [ mul_matrix_matrix(parent_pose[0], constant_transform[0]), add_matrix_matrix( mul_matrix_matrix(parent_pose[0], constant_transform[1]), parent_pose[1] ) ];
            out2[link_idx] = curr_pose.slice();

            if(joint_type_string === 'prismatic') {
                let joint_value = state[joint.dof_idx];

                let variable_transform = [ identity_matrix(3), [ [joint_value*joint.axis[0][0]], [joint_value*joint.axis[1][0]], [joint_value*joint.axis[2][0]] ] ];
                // curr_pose = mul_matrix_matrix(curr_pose, variable_transform);
                // curr_pose = [ mul_matrix_matrix(curr_pose[0], variable_transform[0]), add_matrix_matrix( mul_matrix_matrix(curr_pose[0], variable_transform[1]), curr_pose[1] ) ];
                curr_pose = map_pose_SO3_and_position(curr_pose, variable_transform);

            } else if(joint_type_string === 'revolute') {
                let joint_value = state[joint.dof_idx];

                let u = joint.axis;
                let un = normalized_matrix(u);
                let us = mul_matrix_scalar(un, joint_value);
                us = unroll_matrix_to_list(us);
                // let se3_mat = vec6_to_se3_mat([us[0], us[1], us[2], 0, 0, 0]);
                // let variable_transform = exp_se3_to_SE3(se3_mat);
                let so3_mat = vec3_to_so3_mat(us);
                let SO3_mat = exp_so3_to_SO3(so3_mat);
                let variable_transform = [ SO3_mat, [[0], [0], [0]] ];

                // curr_pose = mul_matrix_matrix(curr_pose, variable_transform);
                curr_pose = [ mul_matrix_matrix(curr_pose[0], variable_transform[0]), add_matrix_matrix( mul_matrix_matrix(curr_pose[0], variable_transform[1]), curr_pose[1] ) ];

            } else if(joint_type_string === 'floating') {
                let rd = joint.rotation_dof_idxs;
                let td = joint.translation_dof_idxs;

                let rv = [ state[rd[0]], state[rd[1]], state[rd[2]] ];
                let tv = [ state[td[0]], state[td[1]], state[td[2]] ];

                let so3_mat = vec3_to_so3_mat(rv);
                let R = exp_so3_to_SO3(so3_mat);

                // let variable_transform = [
                //     [ R[0][0], R[0][1], R[0][2], tv[0] ],
                //     [ R[1][0], R[1][1], R[1][2], tv[1] ],
                //     [ R[2][0], R[2][1], R[2][2], tv[2] ],
                //     [ 0, 0, 0, 1 ]
                // ];
                let variable_transform = [ R, [ [tv[0]], [tv[1]], [tv[2]] ] ];

                // curr_pose = mul_matrix_matrix(curr_pose, variable_transform);
                curr_pose = [ mul_matrix_matrix(curr_pose[0], variable_transform[0]), add_matrix_matrix( mul_matrix_matrix(curr_pose[0], variable_transform[1]), curr_pose[1] ) ];
            }

            // console.log(curr_pose);
            out3[link_idx] = curr_pose.slice();
        });
    }

    return [out1, out2, out3];
}

/**
 * Sets the robot state.
 * @param {Object} engine - The Three.js engine instance.
 * @param {Object} robot - The robot object.
 * @param {Array&lt;number>} state - The robot state.
 */
export function set_robot_state(engine, robot, state) {
    let fk = forward_kinematics_SE3(robot, state);
    set_robot_state_from_SE3_fk_result(engine, robot, fk);
}

/**
 * Sets the robot state using SE3 forward kinematics results.
 * @param {Object} engine - The Three.js engine instance.
 * @param {Object} robot - The robot object.
 * @param {Array&lt;Array&lt;Array&lt;number>>>} fk_result - The SE3 forward kinematics result.
 */
export function set_robot_state_from_SE3_fk_result(engine, robot, fk_result) {
    for(let i=0; i&lt;fk_result.length; i++) {
        robot.set_link_mesh_pose_from_SE3_matrix(engine, i, fk_result[i]);
        robot.set_hull_mesh_pose_from_SE3_matrix(engine, i, fk_result[i]);
    }
}

/**
 * Sets the robot state using SO3 and position forward kinematics results.
 * @param {Object} engine - The Three.js engine instance.
 * @param {Object} robot - The robot object.
 * @param {Array&lt;Array>} fk_result - The SO3 and position forward kinematics result.
 */
export function set_robot_state_from_SO3_and_position_fk_result(engine, robot, fk_result) {
    for(let i=0; i&lt;fk_result.length; i++) {
        robot.set_link_mesh_pose_from_SO3_matrix_and_position(engine, i, fk_result[i][0], fk_result[i][1]);
    }
}

/**
 * Solves the inverse kinematics problem using SO3 matrices and positions.
 * @param {Object} robot - The robot object.
 * @param {Array&lt;number>} init_state - The initial state of the robot.
 * @param {Array&lt;Object>} ik_goals - The inverse kinematics goals.
 * @param {number} [max_iter=100] - The maximum number of iterations.
 * @returns {Array&lt;number>} - The solved state of the robot.
 */
export function inverse_kinematics_SO3_and_position(robot, init_state, ik_goals, max_iter = 100) {
    let f = x => {
        let fk_res = forward_kinematics_SO3_and_position(robot, x);

        let out_sum = 0.0;
        ik_goals.forEach(ik_goal => {
            let mode = ik_goal.mode;
            let curr_pose = fk_res[ik_goal.link_idx];
            let goal_pose = ik_goal.goal_pose;

            if(mode === 'combined') {

                let disp = displacement_pose_SO3_and_position(curr_pose, goal_pose);
                let ln = ln_SO3_and_t_to_so3_and_v(disp[0], disp[1]);
                let v1 = unroll_matrix_to_list(so3_mat_to_vec3(ln[0]));
                let v2 = unroll_matrix_to_list(ln[1]);
                let v = [ v1[0], v1[1], v1[2], v2[0], v2[1], v2[2] ];
                let dis = frobenius_norm_matrix(v);

                out_sum += Math.pow(dis, 2);

            } else if(mode === 'separate') {



            } else if(mode === 'position') {

                let curr_position = curr_pose[1];
                let goal_position = goal_pose[1];

                let diff = sub_matrix_matrix(curr_position, goal_position);
                let dis = frobenius_norm_matrix(diff);

                out_sum += Math.pow(dis, 2);
            }
        });

        return out_sum;
    }

    return optimization_powell(f, init_state, max_iter);
}

/**
 * Optimizes the robot's kinematic state to achieve specified goals.
 * @param {Object} robot - The robot object.
 * @param {Array&lt;number>} init_state - The initial state of the robot.
 * @param {Array&lt;Object>} goals - The optimization goals.
 * @param {number} max_iter - The maximum number of iterations.
 * @param {string} [solver='bfgs'] - The optimization solver to use.
 * @returns {Array&lt;number>} - The optimized state of the robot.
 */
export function robot_kinematic_opt(robot, init_state, goals, max_iter, solver='bfgs') {
    let f = x => {
        let fk_res = forward_kinematics_SO3_and_position(robot, x);

        let out_sum = 0.0;
        goals.forEach(goal => {
            let mode_string = goal.mode_string;

            if(mode_string === 'pose_match') {
                let curr_pose = fk_res[goal.link_idx];
                let goal_pose = goal.goal_pose;

                let disp = displacement_pose_SO3_and_position(curr_pose, goal_pose);
                let ln = ln_SO3_and_t_to_so3_and_v(disp[0], disp[1]);
                let v1 = unroll_matrix_to_list(so3_mat_to_vec3(ln[0]));
                let v2 = unroll_matrix_to_list(ln[1]);
                let v = [ v1[0], v1[1], v1[2], v2[0], v2[1], v2[2] ];
                let dis = frobenius_norm_matrix(v);

                out_sum += goal.weight*Math.pow(dis, 2);

            } else if(mode_string === 'pose_match_wrong') {
                let curr_pose = fk_res[goal.link_idx];
                let goal_pose = goal.goal_pose;

                let sub1 = sub_matrix_matrix(curr_pose[0], goal_pose[0]);
                let sub2 = sub_matrix_matrix(curr_pose[1], goal_pose[1]);

                let n1 = frobenius_norm_matrix(sub1);
                let n2 = frobenius_norm_matrix(sub2);

                out_sum += Math.pow(n1 + n2, 2);
            } else if(mode_string === 'position_match') {
                let curr_pose = fk_res[goal.link_idx];
                let goal_position = goal.goal_position;

                let curr_position = curr_pose[1];

                let diff = sub_matrix_matrix(curr_position, goal_position);
                let dis = frobenius_norm_matrix(diff);

                out_sum += goal.weight*Math.pow(dis, 2);

            } else if(mode_string === 'look_at') {
                let curr_pose = fk_res[goal.link_idx];
                let forward_axis = goal.forward_axis;
                let mapped_axis = mul_matrix_matrix(curr_pose[0], forward_axis);
                let a = curr_pose[1];
                let b = add_matrix_matrix(mul_matrix_scalar(mapped_axis, 20.0), a);

                let pt = goal.look_at_position;

                let dis = pt_dis_to_line(pt, a, b, true);

                out_sum += goal.weight*Math.pow(dis, 2);
            } else if(mode_string === 'upright') {
                let curr_pose = fk_res[goal.link_idx];
                let side_axis = goal.side_axis;
                let mapped_axis = mul_matrix_matrix(curr_pose[0], side_axis);
                let up_axis = [[0], [0], [1]];
                let dot = dot_product(mapped_axis, up_axis);
                out_sum += goal.weight*Math.pow(dot, 2);
            }
        });

        return out_sum;
    }

    // return optimization_powell(f, init_state, max_iter);
    return optimization_solve(f, init_state, max_iter, solver);
    // return optimization_gradient_descent(f, init_state, max_iter);
}

export class OptGoalSpecPoseMatch {
    /**
     * Creates an optimization goal for matching a pose.
     * @param {Array} goal_pose - The desired pose.
     * @param {number} link_idx - The index of the link to match.
     * @param {number} [weight=1.0] - The weight of the goal.
     */
    constructor(link_idx, weight=1.0) {
        this.mode_string = 'pose_match'
        this.link_idx = link_idx;
        this.weight = weight;
    }
}

/**
 * Class representing an optimization goal for matching a pose.
 */
export class OptGoalPoseMatch {
    constructor(goal_pose, link_idx, weight=1.0) {
        this.goal_pose = goal_pose;
        this.mode_string = 'pose_match'
        this.link_idx = link_idx;
        this.weight = weight;
    }
}

export class OptGoalSpecPoseMatchWrong {
    constructor(link_idx, weight=1.0) {
        this.mode_string = 'pose_match_wrong'
        this.link_idx = link_idx;
        this.weight = weight;
    }
}

export class OptGoalPoseMatchWrong {
    constructor(goal_pose, link_idx, weight=1.0) {
        this.goal_pose = goal_pose;
        this.mode_string = 'pose_match_wrong'
        this.link_idx = link_idx;
        this.weight = weight;
    }
}

export class OptGoalSpecPositionMatch {
    constructor(link_idx, weight = 1.0) {
        this.mode_string = 'position_match'
        this.link_idx = link_idx;
        this.weight = weight;
    }
}

export class OptGoalPositionMatch {
    constructor(goal_position, link_idx, weight = 1.0) {
        this.goal_position = goal_position;
        this.mode_string = 'position_match'
        this.link_idx = link_idx;
        this.weight = weight;
    }
}

export class OptGoalSpecLookAt {
    constructor(link_idx, forward_axis, weight=1.0) {
        this.mode_string = 'look_at'
        this.link_idx = link_idx;
        this.forward_axis = forward_axis;
        this.weight = weight;
    }
}

export class OptGoalLookAt {
    constructor(look_at_position, link_idx, forward_axis, weight=1.0) {
        this.look_at_position = look_at_position;
        this.mode_string = 'look_at'
        this.link_idx = link_idx;
        this.forward_axis = forward_axis;
        this.weight = weight;
    }
}

export class OptGoalSpecUpright {
    constructor(link_idx, side_axis, weight=1.0) {
        this.mode_string = 'upright'
        this.link_idx = link_idx;
        this.side_axis = side_axis;
        this.weight = weight;
    }
}

export class OptGoalUpright {
    constructor(link_idx, side_axis, weight=1.0) {
        this.mode_string = 'upright'
        this.link_idx = link_idx;
        this.side_axis = side_axis;
        this.weight = weight;
    }
}

export class IKGoal {
    // goal_pose at this point should only be an SO3 matrix and position
    // mode can be 'combined', 'separate', or 'position'
    constructor(link_idx, goal_pose, mode) {
        this.link_idx = link_idx;
        this.goal_pose = goal_pose;
        this.mode = mode;
    }
}

/**
 * Class representing a robot visualizer for forward kinematics with sliders.
 */
export class RobotFKSlidersVisualizer {
    /**
     * Creates a visualizer for robot forward kinematics.
     * @param {Object} robot - The robot object.
     * @param {boolean} [init_display_mesh=true] - Whether to display the mesh initially.
     * @param {boolean} [init_display_wireframe=false] - Whether to display the wireframe initially.
     * @param {boolean} [init_display_link_mesh_only_with_frame=false] - Whether to display the link mesh only with the frame initially.
     * @param {boolean} [init_all_links_selected=false] - Whether to select all links initially.
     * @param {boolean} [freeze_display_mesh=false] - Whether to freeze the display mesh option.
     * @param {boolean} [freeze_display_wireframe=false] - Whether to freeze the display wireframe option.
     * @param {boolean} [freeze_display_link_mesh_only_with_frame=false] - Whether to freeze the display link mesh only with the frame option.
     * @param {boolean} [freeze_dof_sliders=false] - Whether to freeze the DOF sliders.
     * @param {boolean} [interpolator=false] - Whether to enable interpolation.
     */
    constructor(robot,
                init_display_mesh=true,
                init_display_wireframe=false,
                init_display_link_mesh_only_with_frame=false,
                init_all_links_selected=false,
                freeze_display_mesh=false,
                freeze_display_wireframe=false,
                freeze_display_link_mesh_only_with_frame=false,
                freeze_dof_sliders=false,
                interpolator=false) {

        this.robot = robot;
        this.interpolator = interpolator;

        this.actions = {};
        this.settings = {
            display_wireframe:init_display_wireframe,
            display_mesh:init_display_mesh,
            display_link_mesh_only_with_frame:init_display_link_mesh_only_with_frame,
            mesh_source: 'stl',
            mesh_source_changed: false,
        };

        this.interpolator_settings = {
            t:0,
            speed:1,
            is_playing:false
        }

        this.interpolator_actions = {
            play: () => {
                this.interpolator_settings.is_playing = true;
            },
            stop: () => {
                this.interpolator_settings.is_playing = false;
            }
        }

        let gui = get_default_lil_gui(300);
        this.gui = gui;

        // Add dropdown to the GUI
        // Define options for dropdown
        let options = {
            'STL': 'stl',
            'GLB': 'glb',
            'Original': 'original_mesh',
            'Convex Decomposition': 'convex_decomposition',
            'Convex Hulls': 'convex_hull',
            //'Convex Decomposition': robot.convex_decomposition_mesh_config
        };

        this.gui.add(this.settings, 'mesh_source', options).name('Mesh Source').onChange((value) => {
            this.settings.mesh_source_changed = true;
            console.log('changed mesh source');
        });

        let a = gui.add(this.settings, 'display_mesh').name('Display Mesh');
        if(freeze_display_mesh) { a.disable(); }
        let b = gui.add(this.settings, 'display_wireframe').name('Display Wireframe');
        if(freeze_display_wireframe) { b.disable(); }
        let c = gui.add(this.settings, 'display_link_mesh_only_with_frame').name('Display Mesh only with Frame');
        if(freeze_display_link_mesh_only_with_frame) { c.disable(); }

        let init_dofs = [];

        let dof_folder = gui.addFolder('DOFs');
        let dof_idx = 0;
        for(let i = 0; i &lt; robot.joints.length; i++) {
            let joint = robot.joints[i];
            if (joint.joint_num_dofs > 0) {
                if(joint.joint_type_string === 'floating') {
                    for(let j=0; j &lt; 3; j++) {
                        this.settings['dof' + dof_idx.toString()] = 0;
                        let slider = dof_folder.add(this.settings, 'dof' + dof_idx.toString(), -3.14, 3.14);
                        if(freeze_dof_sliders) {slider.disable();}
                        this.actions['dof' + dof_idx.toString() + 'reset'] = () => {
                            this.settings['dof' + dof_idx.toString()] = 0;
                            refresh_displays(gui);
                        }
                        init_dofs.push(0);
                        dof_idx++;
                    }
                    for(let j=0; j &lt; 3; j++) {
                        this.settings['dof' + dof_idx.toString()] = 0;
                        let slider = dof_folder.add(this.settings, 'dof' + dof_idx.toString(), -1, 1);
                        if(freeze_dof_sliders) {slider.disable();}
                        this.actions['dof' + dof_idx.toString() + 'reset'] = () => {
                            this.settings['dof' + dof_idx.toString()] = 0;
                            refresh_displays(gui);
                        }
                        init_dofs.push(0);
                        dof_idx++;
                    }
                } else {
                    let joint_lower_bound = joint.lower_bound;
                    let joint_upper_bound = joint.upper_bound;
                    this.settings['dof' + dof_idx.toString()] = Math.max(Math.min(0, joint_upper_bound), joint_lower_bound);
                    init_dofs.push(Math.max(Math.min(0, joint_upper_bound), joint_lower_bound));
                    let slider = dof_folder.add(this.settings, 'dof' + dof_idx.toString(), joint_lower_bound, joint_upper_bound);
                    if(freeze_dof_sliders) {slider.disable();}
                    this.actions['dof' + dof_idx.toString() + 'reset'] = () => {
                        this.settings['dof' + dof_idx.toString()] = 0;
                        refresh_displays(gui);
                    }
                    // dof_folder.add(this.actions, 'dof' + dof_idx.toString() + 'reset').name('Reset DOF');
                    dof_idx += 1;
                }
            }
        }

        let actions_folder =  gui.addFolder('Actions');
        this.actions['reset_all'] = () => {
            for(let i = 0; i &lt; robot.num_dofs(); i++) {
                this.settings['dof' + i.toString()] = init_dofs[i];
            }
            refresh_displays(gui);
        };
        actions_folder.add(this.actions, 'reset_all').name('Reset');

        if (interpolator) {
            let interpolator_folder = gui.addFolder('Interpolator');
            this.interpolator_max = this.robot.links.length * 3 + 3;
            interpolator_folder.add(this.interpolator_settings, 't', 0, this.interpolator_max);
            interpolator_folder.add(this.interpolator_settings, 'speed', 0.0001, 10).name('playback speed');
            interpolator_folder.add(this.interpolator_actions, 'play');
            interpolator_folder.add(this.interpolator_actions, 'stop');
        }

        let links_folder = gui.addFolder('Links');
        for(let i=0; i &lt; robot.links.length; i++) {
            let val = false;
            if(init_all_links_selected) { val = true; }
            this.settings['link' + i.toString() + 'frame'] = val;
            links_folder.add(this.settings, 'link' + i.toString() + 'frame').name('link ' + i.toString() + ': ' + robot.links[i].link_name);
        }
        links_folder.close();

        let bounding_spheres_folder = gui.addFolder('Bounding Spheres');
        for(let i=0; i &lt; robot.links.length; i++) {
            let val = false;
            if(init_all_links_selected) { val = true; }
            this.settings['link' + i.toString() + 'bounding_sphere'] = val;
            bounding_spheres_folder.add(this.settings, 'link' + i.toString() + 'bounding_sphere').name(robot.links[i].link_name + ' b. sphere');
        }
        bounding_spheres_folder.close();


        let bounding_box_folder = gui.addFolder('Bounding Boxes');
        for(let i=0; i &lt; robot.links.length; i++) {
            let val = false;
            if(init_all_links_selected) { val = true; }
            this.settings['link' + i.toString() + 'bounding_box'] = val;
            bounding_box_folder.add(this.settings, 'link' + i.toString() + 'bounding_box').name(robot.links[i].link_name + ' b. box');
        }
        bounding_box_folder.close();

        let decomposed_bounding_box_folder = gui.addFolder('Decomposed Bounding Boxes');
        for(let i=0; i &lt; robot.links.length; i++) {
            let val = false;
            if(init_all_links_selected) { val = true; }
            this.settings['link' + i.toString() + 'decomposed_bounding_box'] = val;
            decomposed_bounding_box_folder.add(this.settings, 'link' + i.toString() + 'decomposed_bounding_box').name(robot.links[i].link_name + ' decomposed b. boxes');
        }
        decomposed_bounding_box_folder.close();

        let decomposed_bounding_spheres_folder = gui.addFolder('Decomposed Bounding Spheres');
        for(let i=0; i &lt; robot.links.length; i++) {
            let val = false;
            if(init_all_links_selected) { val = true; }
            this.settings['link' + i.toString() + 'decomposed_bounding_sphere'] = val;
            decomposed_bounding_spheres_folder.add(this.settings, 'link' + i.toString() + 'decomposed_bounding_sphere').name(robot.links[i].link_name + ' decomposed b. spheres');
        }
        decomposed_bounding_spheres_folder.close();

        let convex_hull_folder = gui.addFolder('Convex Hulls');
        for(let i=0; i &lt; robot.links.length; i++) {
            let val = false;
            if(init_all_links_selected) { val = true; }
            this.settings['link' + i.toString() + 'hull'] = val;
            convex_hull_folder.add(this.settings, 'link' + i.toString() + 'hull').name(robot.links[i].link_name + ' hull');
        }
        convex_hull_folder.close();

        this.actions['select_all'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'frame'] = true;
            }
            refresh_displays(gui);
        };

        this.actions['deselect_all'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'frame'] = false;
            }
            refresh_displays(gui);
        };

        this.actions['select_all_hulls'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'hull'] = true;
            }
            refresh_displays(gui);
        };

        this.actions['deselect_all_hulls'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'hull'] = false;
            }
            refresh_displays(gui);
        };

        this.actions['select_all_spheres'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'bounding_sphere'] = true;
            }
            refresh_displays(gui);
        };

        this.actions['deselect_all_spheres'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'bounding_sphere'] = false;
            }
            refresh_displays(gui);
        };

        this.actions['select_all_boxes'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'bounding_box'] = true;
            }
            refresh_displays(gui);
        };

        this.actions['deselect_all_boxes'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'bounding_box'] = false;
            }
            refresh_displays(gui);
        };

        this.actions['select_all_decomposed_boxes'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'decomposed_bounding_box'] = true;
            }
            refresh_displays(gui);
        };

        this.actions['deselect_all_decomposed_boxes'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'decomposed_bounding_box'] = false;
            }
            refresh_displays(gui);
        };

        this.actions['select_all_decomposed_spheres'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'decomposed_bounding_sphere'] = true;
            }
            refresh_displays(gui);
        };

        this.actions['deselect_all_decomposed_spheres'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'decomposed_bounding_sphere'] = false;
            }
            refresh_displays(gui);
        };

        actions_folder.add(this.actions, 'select_all').name('Select All Frames');
        actions_folder.add(this.actions, 'deselect_all').name('Deselect All Frames');

        actions_folder.add(this.actions, 'select_all_boxes').name('Select All B. Boxes');
        actions_folder.add(this.actions, 'deselect_all_boxes').name('Deselect All B. Boxes');

        actions_folder.add(this.actions, 'select_all_spheres').name('Select All B. Spheres');
        actions_folder.add(this.actions, 'deselect_all_spheres').name('Deselect All B. Spheres');

        actions_folder.add(this.actions, 'select_all_decomposed_boxes').name('Select All Decomposed B. Boxes');
        actions_folder.add(this.actions, 'deselect_all_decomposed_boxes').name('Deselect All Decomposed B. Boxes');

        actions_folder.add(this.actions, 'select_all_decomposed_spheres').name('Select All Decomposed B. Spheres');
        actions_folder.add(this.actions, 'deselect_all_decomposed_spheres').name('Deselect All Decomposed B. Spheres');

        actions_folder.add(this.actions, 'select_all_hulls').name('Select All Convex Hulls');
        actions_folder.add(this.actions, 'deselect_all_hulls').name('Deselect All Convex Hulls');

        this.gui = gui;

    }

    set_mesh_configs(config1, config2) {

    }

    /**
     * Updates the robot state and visual elements based on the current settings.
     * @param {Object} three_engine - The Three.js engine instance.
     */
    three_loop_function(three_engine) {

        // Added to implment choosing which mesh files to use
        if (this.settings.mesh_source_changed) {
            this.robot.despawn_robot(three_engine);
            this.robot.display_mesh_type = this.settings.mesh_source;
            this.robot.links = this.robot.get_robot_links();
            console.log(this.robot.links);
            this.robot.spawn_robot(three_engine);
            this.settings.mesh_source_changed = false;
        }

        if(this.interpolator) {
            if(this.interpolator_settings.is_playing) {
                this.interpolator_settings.t += this.interpolator_settings.speed * 0.01;
                if (this.interpolator_settings.t > this.interpolator_max) {
                    this.interpolator_settings.t = 0;
                }
                refresh_displays(this.gui);
            }
        }

        let state = [];
        for(let i=0; i &lt; this.robot.num_dofs(); i++) {
            let joint_value = this.settings['dof' + i.toString()];
            state.push(joint_value);
        }
        if(!this.interpolator) {
            set_robot_state(three_engine, this.robot, state);
        }

        this.robot.set_wireframe_visibility(three_engine, this.settings.display_wireframe);
        // if(!this.settings.display_link_mesh_only_with_frame) {
        this.robot.set_mesh_visibility(three_engine, this.settings.display_mesh);
        // }
        this.robot.set_convex_hull_mesh_visibility(three_engine, false)

        // let fk = forward_kinematics_SE3(this.robot, state);
        // let fk = forward_kinematics_SO3_and_position(this.robot, state);
        let fk_all = forward_kinematics_SO3_and_position_all(this.robot, state);
        for(let i=0; i &lt; this.robot.links.length; i++) {
            if(this.settings.display_link_mesh_only_with_frame &amp;&amp; this.settings.display_mesh) {
                this.robot.set_link_mesh_visibility(three_engine, i, false);
            }
            if(this.settings.display_link_mesh_only_with_frame &amp;&amp; this.settings.display_wireframe) {
                this.robot.set_link_wireframe_visibility(three_engine, i, false);
            }

            let frame;
            if(this.interpolator) {
                let t = this.interpolator_settings.t;
                let init_idx = this.robot.link_to_kinematic_hierarchy_order_idx[i] * 3;
                if(t >= init_idx &amp;&amp; t &lt;= init_idx + 3) {
                    // frame = [ identity_matrix(3), [ [0], [0], [1] ] ];
                    let v = 3 - ((init_idx + 3) - t);
                    if(0 &lt;= v &amp;&amp; v &lt;= 1) {
                        let T1 = [ identity_matrix(3), [ [0], [0], [0] ] ];
                        let T2 = fk_all[0][i];
                        frame = interpolate_poses_SO3_and_position(T1, T2, v);
                    } else if(1 &lt;= v &amp;&amp; v &lt;= 2) {
                        let vv = v - 1;
                        let T1 = fk_all[0][i];
                        let T2 = fk_all[1][i];
                        frame = interpolate_poses_SO3_and_position(T1, T2, vv);
                    } else if(2 &lt;= v &amp;&amp; v &lt;= 3) {
                        let vv = v - 2;
                        let T1 = fk_all[1][i];
                        let T2 = fk_all[2][i];
                        frame = interpolate_poses_SO3_and_position(T1, T2, vv);
                    }

                } else if(init_idx &lt; t) {
                    frame = fk_all[2][i];
                } else {
                    frame = [ identity_matrix(3), [ [0], [0], [0] ] ];
                }
            } else {
                frame = fk_all[2][i];
            }

            if(this.interpolator) {
                this.robot.set_link_mesh_pose_from_SO3_matrix_and_position(three_engine, i, frame[0], frame[1]);
            }

            if(
                this.settings['link' + i.toString() + 'frame'] ||
                this.settings['link' + i.toString() + 'bounding_sphere'] ||
                this.settings['link' + i.toString() + 'bounding_box'] ||
                this.settings['link' + i.toString() + 'decomposed_bounding_box'] ||
                this.settings['link' + i.toString() + 'decomposed_bounding_sphere']
            ) {
                let R = frame[0];
                let t = frame[1];
                let rxv = [ [R[0][0]], [R[1][0]], [R[2][0]] ];
                let ryv = [ [R[0][1]], [R[1][1]], [R[2][1]] ];
                let rzv = [ [R[0][2]], [R[1][2]], [R[2][2]] ];
                // let t = [ [frame[0][3]], [frame[1][3]], [frame[2][3]] ];

                if(this.settings['link' + i.toString() + 'frame']) {
                    three_engine.draw_debug_line(t, add_matrix_matrix(t, mul_matrix_scalar(rxv, 0.05)), true, 0.002, 0xff3333);
                    three_engine.draw_debug_line(t, add_matrix_matrix(t, mul_matrix_scalar(ryv, 0.05)), true, 0.002, 0x33ff33);
                    three_engine.draw_debug_line(t, add_matrix_matrix(t, mul_matrix_scalar(rzv, 0.05)), true, 0.002, 0x3333ff);

                    if(this.settings.display_link_mesh_only_with_frame &amp;&amp; this.settings.display_mesh) {
                        this.robot.set_link_mesh_visibility(three_engine, i, true);
                    }
                    if(this.settings.display_link_mesh_only_with_frame &amp;&amp; this.settings.display_wireframe) {
                        this.robot.set_link_wireframe_visibility(three_engine, i, true);
                    }
                }

                if(this.settings['link' + i.toString() + 'bounding_sphere']) {
                    draw_bounding_sphere(three_engine, this.robot.bounding_box_config, i, R, t);
                }

                if(this.settings['link' + i.toString() + 'bounding_box']) {
                    draw_obb(three_engine, this.robot.bounding_box_config, i, R, t);
                }

                if(this.settings['link' + i.toString() + 'decomposed_bounding_box']) {
                    this.robot.bounding_box_config.decomposition_obbs.map((config, index) => draw_decomposed_obb(three_engine, this.robot.bounding_box_config, i, index, R, t));
                }

                if(this.settings['link' + i.toString() + 'decomposed_bounding_sphere']) {
                    this.robot.bounding_box_config.decomposition_bounding_spheres.map((config, index) => draw_decomposed_bounding_sphere(three_engine, this.robot.bounding_box_config, i, index, R, t));
                }
            }

            if(this.settings['link' + i.toString() + 'hull']) {
                this.robot.set_link_convex_hull_mesh_visibility(three_engine, i, true);
            }
        }

        return fk_all[2];
    }
}

/**
 * Class representing a robot visualizer with optimization capabilities.
 */
export class RobotOptVisualizer {
    /**
     * Creates a visualizer for robot kinematic optimization.
     * @param {Object} three_engine - The Three.js engine instance.
     * @param {Object} robot - The robot object.
     * @param {Array&lt;number>} init_state - The initial state of the robot.
     * @param {Array&lt;Object>} goal_specs - The optimization goal specifications.
     * @param {boolean} [init_display_mesh=true] - Whether to display the mesh initially.
     * @param {boolean} [init_display_wireframe=false] - Whether to display the wireframe initially.
     * @param {boolean} [init_display_link_mesh_only_with_frame=false] - Whether to display the link mesh only with the frame initially.
     * @param {boolean} [init_all_links_selected=false] - Whether to select all links initially.
     * @param {boolean} [init_continuous_solves=true] - Whether to continuously solve the optimization problem.
     * @param {boolean} [freeze_display_mesh=false] - Whether to freeze the display mesh option.
     * @param {boolean} [freeze_display_wireframe=false] - Whether to freeze the display wireframe option.
     * @param {boolean} [freeze_display_link_mesh_only_with_frame=false] - Whether to freeze the display link mesh only with the frame option.
     * @param {boolean} [freeze_continuous_solves=false] - Whether to freeze the continuous solves option.
     * @param {boolean} [disable_solve=false] - Whether to disable solving the optimization problem.
     * @param {string} [solver='bfgs'] - The optimization solver to use.
     */
    constructor(three_engine,
                robot,
                init_state,
                goal_specs,
                init_display_mesh=true,
                init_display_wireframe=false,
                init_display_link_mesh_only_with_frame=false,
                init_all_links_selected=false,
                init_continuous_solves= true,
                freeze_display_mesh=false,
                freeze_display_wireframe=false,
                freeze_display_link_mesh_only_with_frame=false,
                freeze_continuous_solves=false,
                disable_solve=false,
                solver='bfgs') {

        this.robot = robot;
        this.init_state = init_state;
        this.curr_state = init_state;
        this.curr_solve = init_state;
        this.prev_solve = init_state;
        this.goal_specs = goal_specs;
        this.first_loop = true;
        this.solver = solver;

        this.solve_now = false;
        this.reset = false;
        this.toggle_widget_mode = false;
        this.actions = {
            solve_now: () => {
                this.solve_now = true;
            },
            reset: () => {
                this.reset = true;
            },
            toggle_widget_mode: () => {
                this.toggle_widget_mode = true;
        }
        };
        this.settings = {
            display_wireframe:init_display_wireframe,
            display_mesh:init_display_mesh,
            display_link_mesh_only_with_frame:init_display_link_mesh_only_with_frame,
            continuous_solves:init_continuous_solves
        };

        let gui = get_default_lil_gui();

        let a = gui.add(this.settings, 'display_mesh').name('Display Mesh');
        if(freeze_display_mesh) { a.disable(); }
        let b = gui.add(this.settings, 'display_wireframe').name('Display Wireframe');
        if(freeze_display_wireframe) { b.disable(); }
        let c = gui.add(this.settings, 'display_link_mesh_only_with_frame').name('Display Mesh only with Frame');
        if(freeze_display_link_mesh_only_with_frame) { c.disable(); }
        let d = gui.add(this.settings, 'continuous_solves').name('Continuous solves');
        if(freeze_continuous_solves) { d.disable(); }
        let e = gui.add(this.actions, 'solve_now').name('Solve now');
        if(disable_solve) { e.disable(); }
        gui.add(this.actions, 'reset').name('Reset');
        gui.add(this.actions, 'toggle_widget_mode').name('Toggle transform gizmo mode');

        let init_dofs = [];

        let dof_folder = gui.addFolder('DOFs');
        let dof_idx = 0;
        for(let i = 0; i &lt; robot.joints.length; i++) {
            let joint = robot.joints[i];
            if (joint.joint_num_dofs > 0) {
                if(joint.joint_type_string === 'floating') {
                    for(let j=0; j &lt; 3; j++) {
                        this.settings['dof' + dof_idx.toString()] = 0;
                        let slider = dof_folder.add(this.settings, 'dof' + dof_idx.toString(), -3.14, 3.14);
                        slider.disable();
                        // this.actions['dof' + dof_idx.toString() + 'reset'] = () => {
                        //     this.settings['dof' + dof_idx.toString()] = 0;
                        //     refresh_displays(gui);
                        // }
                        init_dofs.push(0);
                        dof_idx++;
                    }
                    for(let j=0; j &lt; 3; j++) {
                        this.settings['dof' + dof_idx.toString()] = 0;
                        let slider = dof_folder.add(this.settings, 'dof' + dof_idx.toString(), -1, 1);
                        slider.disable();
                        // this.actions['dof' + dof_idx.toString() + 'reset'] = () => {
                        //     this.settings['dof' + dof_idx.toString()] = 0;
                        //     refresh_displays(gui);
                        // }
                        init_dofs.push(0);
                        dof_idx++;
                    }
                } else {
                    let joint_lower_bound = joint.lower_bound;
                    let joint_upper_bound = joint.upper_bound;
                    this.settings['dof' + dof_idx.toString()] = Math.max(Math.min(0, joint_upper_bound), joint_lower_bound);
                    init_dofs.push(Math.max(Math.min(0, joint_upper_bound), joint_lower_bound));
                    let slider = dof_folder.add(this.settings, 'dof' + dof_idx.toString(), joint_lower_bound, joint_upper_bound);
                    slider.disable();
                    // this.actions['dof' + dof_idx.toString() + 'reset'] = () => {
                    //     this.settings['dof' + dof_idx.toString()] = 0;
                    //     refresh_displays(gui);
                    // }
                    // dof_folder.add(this.actions, 'dof' + dof_idx.toString() + 'reset').name('Reset DOF');
                    dof_idx += 1;
                }
            }
        }

        let actions_folder =  gui.addFolder('Actions');

        let links_folder = gui.addFolder('Links');
        for(let i=0; i &lt; robot.links.length; i++) {
            let val = false;
            if(init_all_links_selected) { val = true; }
            this.settings['link' + i.toString() + 'frame'] = val;
            links_folder.add(this.settings, 'link' + i.toString() + 'frame').name('link ' + i.toString() + ': ' + robot.links[i].link_name);
        }

        this.actions['select_all'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'frame'] = true;
            }
            refresh_displays(gui);
        };

        this.actions['deselect_all'] = () => {
            for(let i=0; i &lt; robot.links.length; i++) {
                this.settings['link' + i.toString() + 'frame'] = false;
            }
            refresh_displays(gui);
        };

        actions_folder.add(this.actions, 'select_all').name('Select All Frames');
        actions_folder.add(this.actions, 'deselect_all').name('Deselect All Frames');

        let tge = new TransformGizmoEngine(three_engine);

        let fk_res = forward_kinematics_SO3_and_position(robot, init_state);

        goal_specs.forEach(goal_spec => {
            let mode_string = goal_spec.mode_string;

            if (mode_string === 'pose_match' || mode_string === 'pose_match_wrong') {
                tge.add_gizmo_SO3_matrix_and_position(three_engine, fk_res[goal_spec.link_idx][0], fk_res[goal_spec.link_idx][1]);
            } else if (mode_string === 'position_match') {
                tge.add_gizmo_SO3_matrix_and_position(three_engine, fk_res[goal_spec.link_idx][0], fk_res[goal_spec.link_idx][1]);
            } else if (mode_string === 'look_at') {
                let forward_axis = goal_spec.forward_axis;
                let frame = fk_res[goal_spec.link_idx];
                let mapped_axis = mul_matrix_scalar(mul_matrix_matrix(frame[0], forward_axis), 0.3);
                tge.add_gizmo_SO3_matrix_and_position(three_engine, identity_matrix(3), add_matrix_matrix(frame[1], mapped_axis));
            } else if (mode_string === 'upright') {

            }
        });

        // this.time_of_next_scheduled_solve = this.settings.time_between_solves;
        this.time_of_previous_solve = three_engine.get_time_elapsed();

        this.transform_gizmo_engine = tge;
        this.gui = gui;
    }

    /**
     * Updates the robot state and visual elements, and solves the optimization problem if necessary.
     * @param {Object} three_engine - The Three.js engine instance.
     * @param {number} [max_iter=100] - The maximum number of iterations for the solver.
     */
    three_loop_function(three_engine, max_iter=100) {
        // let now = three_engine.get_time_elapsed();
        // let solve_now = now > this.time_of_next_scheduled_solve;

        if(this.reset) {
            let fk_res = forward_kinematics_SO3_and_position(this.robot, this.init_state);
            for (let i = 0; i &lt; this.robot.num_dofs(); i++) {
                this.settings['dof' + i.toString()] = this.init_state[i];
            }
            refresh_displays(this.gui);

            let gizmo_count = 0;
            this.goal_specs.forEach(goal_spec => {
                let mode_string = goal_spec.mode_string;

                if (mode_string === 'pose_match' || mode_string === 'pose_match_wrong') {
                    this.transform_gizmo_engine.set_pose_of_gizmo_SO3_matrix_and_position(gizmo_count, fk_res[goal_spec.link_idx][0], fk_res[goal_spec.link_idx][1]);
                    gizmo_count += 1;
                    // tge.add_gizmo_SO3_matrix_and_position(three_engine, fk_res[goal_spec.link_idx][0], fk_res[goal_spec.link_idx][1]);
                } else if (mode_string === 'position_match') {
                    this.transform_gizmo_engine.set_pose_of_gizmo_SO3_matrix_and_position(gizmo_count, fk_res[goal_spec.link_idx][0], fk_res[goal_spec.link_idx][1]);
                    gizmo_count += 1;
                    // tge.add_gizmo_SO3_matrix_and_position(three_engine, fk_res[goal_spec.link_idx][0], fk_res[goal_spec.link_idx][1]);
                } else if (mode_string === 'look_at') {
                    let forward_axis = goal_spec.forward_axis;
                    let frame = fk_res[goal_spec.link_idx];
                    let mapped_axis = mul_matrix_scalar(mul_matrix_matrix(frame[0], forward_axis), 0.3);
                    // tge.add_gizmo_SO3_matrix_and_position(three_engine, identity_matrix(3), add_matrix_matrix(frame[1], mapped_axis));
                    this.transform_gizmo_engine.set_pose_of_gizmo_SO3_matrix_and_position(gizmo_count, identity_matrix(3), add_matrix_matrix(frame[1], mapped_axis));
                    gizmo_count += 1;
                } else if (mode_string === 'upright') {

                }
            });
            this.curr_state = this.init_state;
            this.reset = false;
        }

        let solve_now = this.solve_now || this.settings.continuous_solves;
        if(solve_now) {
            let goals = [];
            let gizmo_idx = 0;

            this.goal_specs.forEach(goal_spec => {
                let mode_string = goal_spec.mode_string;

                if (mode_string === 'pose_match') {
                    let pose = this.transform_gizmo_engine.get_gizmo_pose_as_SO3_matrix_and_position(gizmo_idx);
                    gizmo_idx += 1;
                    goals.push(new OptGoalPoseMatch(pose, goal_spec.link_idx, goal_spec.weight));
                } else if (mode_string === 'pose_match_wrong') {
                    let pose = this.transform_gizmo_engine.get_gizmo_pose_as_SO3_matrix_and_position(gizmo_idx);
                    gizmo_idx += 1;
                    goals.push(new OptGoalPoseMatchWrong(pose, goal_spec.link_idx, goal_spec.weight));
                } else if (mode_string === 'position_match') {
                    let pose = this.transform_gizmo_engine.get_gizmo_pose_as_SO3_matrix_and_position(gizmo_idx);
                    gizmo_idx += 1;
                    goals.push(new OptGoalPositionMatch(pose[1], goal_spec.link_idx, goal_spec.weight));
                } else if (mode_string === 'look_at') {
                    let pose = this.transform_gizmo_engine.get_gizmo_pose_as_SO3_matrix_and_position(gizmo_idx);
                    gizmo_idx += 1;
                    goals.push(new OptGoalLookAt(pose[1], goal_spec.link_idx, goal_spec.forward_axis, goal_spec.weight));
                } else if (mode_string === 'upright') {
                    goals.push(new OptGoalUpright(goal_spec.link_idx, goal_spec.side_axis, goal_spec.weight));
                }
            });

            let max_iter_here = max_iter;
            if(!this.settings.continuous_solves) { max_iter_here = 500; }
            let res = robot_kinematic_opt(this.robot, this.curr_state, goals, max_iter_here, this.solver);
            // this.prev_solve = this.curr_solve;
            this.curr_state = res;

            // this.settings['dof' + dof_idx.toString()] = 0;

            // this.time_of_previous_solve = three_engine.get_time_elapsed();
            // this.time_of_next_scheduled_solve = this.time_of_previous_solve + this.settings.time_between_solves;

            this.solve_now = false;
            this.first_loop = false;
        }

        if(this.toggle_widget_mode) {
            this.transform_gizmo_engine.toggle_mode();
            this.toggle_widget_mode = false;
        }

        // let r = (now - this.time_of_previous_solve) / (this.time_of_next_scheduled_solve - this.time_of_previous_solve);
        // r = Math.min(r, 1.0);

        // let curr_state = [];
        // for(let i = 0; i &lt; this.curr_state.length; i++) {
            // curr_state.push(  this.prev_solve[i]*(1-r) + this.curr_solve[i]*r  );
        // }

        // this.curr_state = unroll_matrix_to_list(add_matrix_matrix(mul_matrix_scalar(this.curr_state, 1-r), mul_matrix_scalar(this.curr_solve, r)));
        // console.log(this.curr_state);
        // this.curr_state = curr_state;
        // set_robot_state(three_engine, this.robot, this.curr_state);

        this.robot.set_wireframe_visibility(three_engine, this.settings.display_wireframe);
        this.robot.set_mesh_visibility(three_engine, this.settings.display_mesh);

        let fk_res = forward_kinematics_SO3_and_position(this.robot, this.curr_state);
        // set_robot_state(three_engine, this.robot, this.curr_state);
        set_robot_state_from_SO3_and_position_fk_result(three_engine, this.robot, fk_res);

        for (let i = 0; i &lt; this.robot.num_dofs(); i++) {
            this.settings['dof' + i.toString()] = this.curr_state[i].toFixed(3);
        }
        refresh_displays(this.gui);

        // let fk_all = forward_kinematics_SO3_and_position_all(this.robot, this.curr_state);
        for(let i=0; i &lt; this.robot.links.length; i++) {
            if(this.settings.display_link_mesh_only_with_frame &amp;&amp; this.settings.display_mesh) {
                this.robot.set_link_mesh_visibility(three_engine, i, false);
            }
            if(this.settings.display_link_mesh_only_with_frame &amp;&amp; this.settings.display_wireframe) {
                this.robot.set_link_wireframe_visibility(three_engine, i, false);
            }

            let frame = fk_res[i];

            if(this.settings['link' + i.toString() + 'frame']) {
                let R = frame[0];
                let t = frame[1];
                let rxv = [ [R[0][0]], [R[1][0]], [R[2][0]] ];
                let ryv = [ [R[0][1]], [R[1][1]], [R[2][1]] ];
                let rzv = [ [R[0][2]], [R[1][2]], [R[2][2]] ];
                // let t = [ [frame[0][3]], [frame[1][3]], [frame[2][3]] ];

                three_engine.draw_debug_line(t, add_matrix_matrix(t, mul_matrix_scalar(rxv, 0.05)), true, 0.002, 0xff3333);
                three_engine.draw_debug_line(t, add_matrix_matrix(t, mul_matrix_scalar(ryv, 0.05)), true, 0.002, 0x33ff33);
                three_engine.draw_debug_line(t, add_matrix_matrix(t, mul_matrix_scalar(rzv, 0.05)), true, 0.002, 0x3333ff);

                if(this.settings.display_link_mesh_only_with_frame &amp;&amp; this.settings.display_mesh) {
                    this.robot.set_link_mesh_visibility(three_engine, i, true);
                }
                if(this.settings.display_link_mesh_only_with_frame &amp;&amp; this.settings.display_wireframe) {
                    this.robot.set_link_wireframe_visibility(three_engine, i, true);
                }
            }
        }

        this.goal_specs.forEach(goal_spec => {
            let mode_string = goal_spec.mode_string;

            if(mode_string === 'look_at') {
                let forward_axis = goal_spec.forward_axis;
                let mapped_axis = mul_matrix_matrix(fk_res[goal_spec.link_idx][0], forward_axis);
                let pos = fk_res[goal_spec.link_idx][1];

                three_engine.draw_debug_line(pos, add_matrix_matrix(mul_matrix_scalar(mapped_axis, 3.0), pos), true, 0.0015, 0xffee00);
            }
        });

    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BSpline.html">BSpline</a></li><li><a href="BSplineVisualizer.html">BSplineVisualizer</a></li><li><a href="BSplineVisualizerHelper.html">BSplineVisualizerHelper</a></li><li><a href="BezierSplineSegment.html">BezierSplineSegment</a></li><li><a href="CardinalSplineSegment.html">CardinalSplineSegment</a></li><li><a href="CatmullRomSplineSegment.html">CatmullRomSplineSegment</a></li><li><a href="EulerAngleInterpolatorVisualizer.html">EulerAngleInterpolatorVisualizer</a></li><li><a href="EulerAnglesVisualizer.html">EulerAnglesVisualizer</a></li><li><a href="HermiteSplineSegment.html">HermiteSplineSegment</a></li><li><a href="ImplicitFunctionGrapher.html">ImplicitFunctionGrapher</a></li><li><a href="LinearSplineSegment.html">LinearSplineSegment</a></li><li><a href="NaturalSplineSegment.html">NaturalSplineSegment</a></li><li><a href="OptGoalPoseMatch.html">OptGoalPoseMatch</a></li><li><a href="OptGoalSpecPoseMatch_OptGoalSpecPoseMatch.html">OptGoalSpecPoseMatch</a></li><li><a href="OptimizationBFGS.html">OptimizationBFGS</a></li><li><a href="OptimizationResult.html">OptimizationResult</a></li><li><a href="ParametricCurveBaseClass.html">ParametricCurveBaseClass</a></li><li><a href="ParametricCurveLieGroupAndAlgebraUtil.html">ParametricCurveLieGroupAndAlgebraUtil</a></li><li><a href="ParametricCurveLineTest.html">ParametricCurveLineTest</a></li><li><a href="ParametricCurveThreeVisualizer.html">ParametricCurveThreeVisualizer</a></li><li><a href="ParametricCurveUnitCircle.html">ParametricCurveUnitCircle</a></li><li><a href="ParametricSurfaceBaseClass.html">ParametricSurfaceBaseClass</a></li><li><a href="ParametricSurfaceKleinBottle.html">ParametricSurfaceKleinBottle</a></li><li><a href="ParametricSurfaceLieGroupAndAlgebraUtil.html">ParametricSurfaceLieGroupAndAlgebraUtil</a></li><li><a href="ParametricSurfaceMobiusStrip.html">ParametricSurfaceMobiusStrip</a></li><li><a href="ParametricSurfaceSphere.html">ParametricSurfaceSphere</a></li><li><a href="ParametricSurfaceThreeVisualizer.html">ParametricSurfaceThreeVisualizer</a></li><li><a href="ParametricSurfaceTorus.html">ParametricSurfaceTorus</a></li><li><a href="ParametricSurfaceWaves.html">ParametricSurfaceWaves</a></li><li><a href="PolynomialBasedSpline.html">PolynomialBasedSpline</a></li><li><a href="PolynomialSplineSegmentBaseClass.html">PolynomialSplineSegmentBaseClass</a></li><li><a href="PolynomialSplineSegmentVisualizer.html">PolynomialSplineSegmentVisualizer</a></li><li><a href="PolynomialSplineSegmentVisualizerHelper.html">PolynomialSplineSegmentVisualizerHelper</a></li><li><a href="PolynomialSplineVisualizer.html">PolynomialSplineVisualizer</a></li><li><a href="PolynomialSplineVisualizerHelper.html">PolynomialSplineVisualizerHelper</a></li><li><a href="QuadraticSplineSegment.html">QuadraticSplineSegment</a></li><li><a href="RobotBaseClass.html">RobotBaseClass</a></li><li><a href="RobotFKSlidersVisualizer.html">RobotFKSlidersVisualizer</a></li><li><a href="RobotFromPreprocessor.html">RobotFromPreprocessor</a></li><li><a href="RobotJointBaseClass.html">RobotJointBaseClass</a></li><li><a href="RobotJointFixed.html">RobotJointFixed</a></li><li><a href="RobotJointFloating.html">RobotJointFloating</a></li><li><a href="RobotJointPrismatic.html">RobotJointPrismatic</a></li><li><a href="RobotJointRevolute.html">RobotJointRevolute</a></li><li><a href="RobotLink.html">RobotLink</a></li><li><a href="RobotOptVisualizer.html">RobotOptVisualizer</a></li><li><a href="TransformGizmoEngine.html">TransformGizmoEngine</a></li></ul><h3>Global</h3><ul><li><a href="global.html#add_complex_numbers">add_complex_numbers</a></li><li><a href="global.html#add_matrix_matrix">add_matrix_matrix</a></li><li><a href="global.html#add_wxyz_quaternions">add_wxyz_quaternions</a></li><li><a href="global.html#apply_global_rotation">apply_global_rotation</a></li><li><a href="global.html#arclength_parameterize_spline_interpolate">arclength_parameterize_spline_interpolate</a></li><li><a href="global.html#backtracking_line_search">backtracking_line_search</a></li><li><a href="global.html#calculate_visible_domain">calculate_visible_domain</a></li><li><a href="global.html#convert_3D_point_to_dual_quaternion">convert_3D_point_to_dual_quaternion</a></li><li><a href="global.html#convert_dual_quaternion_to_3D_point">convert_dual_quaternion_to_3D_point</a></li><li><a href="global.html#convert_scalar_vector_to_wxyz_quaternion">convert_scalar_vector_to_wxyz_quaternion</a></li><li><a href="global.html#convert_wxyz_to_scalar_vector_quaternion">convert_wxyz_to_scalar_vector_quaternion</a></li><li><a href="global.html#create_gridlines">create_gridlines</a></li><li><a href="global.html#create_parameterization">create_parameterization</a></li><li><a href="global.html#cross_product">cross_product</a></li><li><a href="global.html#cross_product_unrolled">cross_product_unrolled</a></li><li><a href="global.html#determinant3x3">determinant3x3</a></li><li><a href="global.html#displacement_pose_SO2_and_position">displacement_pose_SO2_and_position</a></li><li><a href="global.html#displacement_pose_SO3_and_position">displacement_pose_SO3_and_position</a></li><li><a href="global.html#distance_to_origin">distance_to_origin</a></li><li><a href="global.html#div_matrix_scalar">div_matrix_scalar</a></li><li><a href="global.html#dot">dot</a></li><li><a href="global.html#dot_product">dot_product</a></li><li><a href="global.html#dot_product_unrolled">dot_product_unrolled</a></li><li><a href="global.html#draw_2d_function">draw_2d_function</a></li><li><a href="global.html#draw_3d_function">draw_3d_function</a></li><li><a href="global.html#draw_bounding_sphere">draw_bounding_sphere</a></li><li><a href="global.html#draw_decomposed_bounding_sphere">draw_decomposed_bounding_sphere</a></li><li><a href="global.html#draw_decomposed_obb">draw_decomposed_obb</a></li><li><a href="global.html#draw_euler_angle_intermediate_coordinate_frame">draw_euler_angle_intermediate_coordinate_frame</a></li><li><a href="global.html#draw_obb">draw_obb</a></li><li><a href="global.html#dual_quaternion_conj_sharp">dual_quaternion_conj_sharp</a></li><li><a href="global.html#dual_quaternion_conj_star">dual_quaternion_conj_star</a></li><li><a href="global.html#dual_quaternion_norm">dual_quaternion_norm</a></li><li><a href="global.html#exp_h1_to_H1_scalar_vector">exp_h1_to_H1_scalar_vector</a></li><li><a href="global.html#exp_h1_to_H1_wxyz">exp_h1_to_H1_wxyz</a></li><li><a href="global.html#exp_se2_to_SE2">exp_se2_to_SE2</a></li><li><a href="global.html#exp_se3_to_SE3">exp_se3_to_SE3</a></li><li><a href="global.html#exp_so2_and_v_to_SO2_and_t">exp_so2_and_v_to_SO2_and_t</a></li><li><a href="global.html#exp_so2_to_SO2">exp_so2_to_SO2</a></li><li><a href="global.html#exp_so3_and_v_to_SO3_and_t">exp_so3_and_v_to_SO3_and_t</a></li><li><a href="global.html#exp_so3_to_SO3">exp_so3_to_SO3</a></li><li><a href="global.html#factorial">factorial</a></li><li><a href="global.html#forward_kinematics_SE3">forward_kinematics_SE3</a></li><li><a href="global.html#forward_kinematics_SO3_and_position">forward_kinematics_SO3_and_position</a></li><li><a href="global.html#forward_kinematics_SO3_and_position_all">forward_kinematics_SO3_and_position_all</a></li><li><a href="global.html#frobenius_norm_matrix">frobenius_norm_matrix</a></li><li><a href="global.html#get_arclength_components">get_arclength_components</a></li><li><a href="global.html#get_bounding_sphere_offset">get_bounding_sphere_offset</a></li><li><a href="global.html#get_bounding_sphere_radius">get_bounding_sphere_radius</a></li><li><a href="global.html#get_curve_exp_0_points">get_curve_exp_0_points</a></li><li><a href="global.html#get_curve_exp_tx_points">get_curve_exp_tx_points</a></li><li><a href="global.html#get_curve_exp_x_points">get_curve_exp_x_points</a></li><li><a href="global.html#get_decomposed_bounding_sphere_offset">get_decomposed_bounding_sphere_offset</a></li><li><a href="global.html#get_decomposed_bounding_sphere_radius">get_decomposed_bounding_sphere_radius</a></li><li><a href="global.html#get_decomposition_obb_RPY">get_decomposition_obb_RPY</a></li><li><a href="global.html#get_decomposition_obb_half_extents">get_decomposition_obb_half_extents</a></li><li><a href="global.html#get_decomposition_obb_offset">get_decomposition_obb_offset</a></li><li><a href="global.html#get_obb_RPY">get_obb_RPY</a></li><li><a href="global.html#get_obb_half_extents">get_obb_half_extents</a></li><li><a href="global.html#get_obb_offset">get_obb_offset</a></li><li><a href="global.html#get_rotation_so3_matrix">get_rotation_so3_matrix</a></li><li><a href="global.html#get_rpy_SO3_matrix">get_rpy_SO3_matrix</a></li><li><a href="global.html#get_rpy_wxyz_quaternion">get_rpy_wxyz_quaternion</a></li><li><a href="global.html#get_surface_exp_0_points">get_surface_exp_0_points</a></li><li><a href="global.html#get_surface_exp_tx_points">get_surface_exp_tx_points</a></li><li><a href="global.html#get_surface_exp_x_points">get_surface_exp_x_points</a></li><li><a href="global.html#get_x_rotation_so3_matrix">get_x_rotation_so3_matrix</a></li><li><a href="global.html#get_xyz_rpy_SE3_matrix">get_xyz_rpy_SE3_matrix</a></li><li><a href="global.html#get_y_rotation_so3_matrix">get_y_rotation_so3_matrix</a></li><li><a href="global.html#get_z_rotation_so3_matrix">get_z_rotation_so3_matrix</a></li><li><a href="global.html#gradient_fd">gradient_fd</a></li><li><a href="global.html#identity_matrix">identity_matrix</a></li><li><a href="global.html#interpolate_poses_SO2_and_position">interpolate_poses_SO2_and_position</a></li><li><a href="global.html#interpolate_poses_SO3_and_position">interpolate_poses_SO3_and_position</a></li><li><a href="global.html#inverse_kinematics_SO3_and_position">inverse_kinematics_SO3_and_position</a></li><li><a href="global.html#inverse_pose_SO2_and_position">inverse_pose_SO2_and_position</a></li><li><a href="global.html#inverse_pose_SO3_and_position">inverse_pose_SO3_and_position</a></li><li><a href="global.html#ln_H1_to_h1_scalar_vector">ln_H1_to_h1_scalar_vector</a></li><li><a href="global.html#ln_H1_to_h1_wxyz">ln_H1_to_h1_wxyz</a></li><li><a href="global.html#ln_SE2_to_se2">ln_SE2_to_se2</a></li><li><a href="global.html#ln_SE3_to_se3">ln_SE3_to_se3</a></li><li><a href="global.html#ln_SO2_and_t_to_so2_and_v">ln_SO2_and_t_to_so2_and_v</a></li><li><a href="global.html#ln_SO2_to_so2">ln_SO2_to_so2</a></li><li><a href="global.html#ln_SO3_and_t_to_so3_and_v">ln_SO3_and_t_to_so3_and_v</a></li><li><a href="global.html#ln_SO3_to_so3">ln_SO3_to_so3</a></li><li><a href="global.html#map_pose_SO2_and_position">map_pose_SO2_and_position</a></li><li><a href="global.html#map_pose_SO3_and_position">map_pose_SO3_and_position</a></li><li><a href="global.html#matrix_inverse_3x3">matrix_inverse_3x3</a></li><li><a href="global.html#matrix_to_quaternion">matrix_to_quaternion</a></li><li><a href="global.html#minimize_GradientDescent">minimize_GradientDescent</a></li><li><a href="global.html#minimize_L_BFGS">minimize_L_BFGS</a></li><li><a href="global.html#minimize_Powell">minimize_Powell</a></li><li><a href="global.html#mul_complex_numbers">mul_complex_numbers</a></li><li><a href="global.html#mul_dual_quaternions">mul_dual_quaternions</a></li><li><a href="global.html#mul_matrix_matrix">mul_matrix_matrix</a></li><li><a href="global.html#mul_matrix_scalar">mul_matrix_scalar</a></li><li><a href="global.html#mul_scalar_vector_quaternions">mul_scalar_vector_quaternions</a></li><li><a href="global.html#mul_wxyz_quaternions">mul_wxyz_quaternions</a></li><li><a href="global.html#normalized_matrix">normalized_matrix</a></li><li><a href="global.html#optimization_bfgs">optimization_bfgs</a></li><li><a href="global.html#optimization_dummy">optimization_dummy</a></li><li><a href="global.html#optimization_gradient_descent">optimization_gradient_descent</a></li><li><a href="global.html#optimization_powell">optimization_powell</a></li><li><a href="global.html#optimization_solve">optimization_solve</a></li><li><a href="global.html#print_var_to_document">print_var_to_document</a></li><li><a href="global.html#proj">proj</a></li><li><a href="global.html#proj_pt_onto_line">proj_pt_onto_line</a></li><li><a href="global.html#proj_scalar">proj_scalar</a></li><li><a href="global.html#pt_dis_to_line">pt_dis_to_line</a></li><li><a href="global.html#quaternion_conj_scalar_vector">quaternion_conj_scalar_vector</a></li><li><a href="global.html#quaternion_conj_wxyz">quaternion_conj_wxyz</a></li><li><a href="global.html#robot_kinematic_opt">robot_kinematic_opt</a></li><li><a href="global.html#roll_list_into_column_vec_matrix">roll_list_into_column_vec_matrix</a></li><li><a href="global.html#roll_list_into_matrix">roll_list_into_matrix</a></li><li><a href="global.html#roll_list_into_row_vec_matrix">roll_list_into_row_vec_matrix</a></li><li><a href="global.html#sandwich_product_scalar_vector_quaternion_and_point">sandwich_product_scalar_vector_quaternion_and_point</a></li><li><a href="global.html#sandwich_product_wxyz_quaternion_and_point">sandwich_product_wxyz_quaternion_and_point</a></li><li><a href="global.html#scalar_to_so2_mat">scalar_to_so2_mat</a></li><li><a href="global.html#se2_mat_to_vec3">se2_mat_to_vec3</a></li><li><a href="global.html#se3_mat_to_vec6">se3_mat_to_vec6</a></li><li><a href="global.html#set_object_orientation_from_SO2_matrix">set_object_orientation_from_SO2_matrix</a></li><li><a href="global.html#set_object_orientation_from_SO3_matrix">set_object_orientation_from_SO3_matrix</a></li><li><a href="global.html#set_object_orientation_from_U1_complex_number">set_object_orientation_from_U1_complex_number</a></li><li><a href="global.html#set_object_orientation_from_scalar_vector_quaternion">set_object_orientation_from_scalar_vector_quaternion</a></li><li><a href="global.html#set_object_orientation_from_wxyz_quaternion">set_object_orientation_from_wxyz_quaternion</a></li><li><a href="global.html#set_object_pose_from_SE2_matrix">set_object_pose_from_SE2_matrix</a></li><li><a href="global.html#set_object_pose_from_SE3_matrix">set_object_pose_from_SE3_matrix</a></li><li><a href="global.html#set_object_pose_from_SO2_matrix_and_position">set_object_pose_from_SO2_matrix_and_position</a></li><li><a href="global.html#set_object_pose_from_SO3_matrix_and_position">set_object_pose_from_SO3_matrix_and_position</a></li><li><a href="global.html#set_object_pose_from_scalar_vector_quaternion_and_position">set_object_pose_from_scalar_vector_quaternion_and_position</a></li><li><a href="global.html#set_object_pose_from_wxyz_quaternion_and_position">set_object_pose_from_wxyz_quaternion_and_position</a></li><li><a href="global.html#set_object_position_2D">set_object_position_2D</a></li><li><a href="global.html#set_object_position_3D">set_object_position_3D</a></li><li><a href="global.html#set_robot_state">set_robot_state</a></li><li><a href="global.html#set_robot_state_from_SE3_fk_result">set_robot_state_from_SE3_fk_result</a></li><li><a href="global.html#set_robot_state_from_SO3_and_position_fk_result">set_robot_state_from_SO3_and_position_fk_result</a></li><li><a href="global.html#shuffleIndicesOf">shuffleIndicesOf</a></li><li><a href="global.html#so2_mat_to_scalar">so2_mat_to_scalar</a></li><li><a href="global.html#so3_and_v_to_vec6">so3_and_v_to_vec6</a></li><li><a href="global.html#so3_mat_to_vec3">so3_mat_to_vec3</a></li><li><a href="global.html#sub_matrix_matrix">sub_matrix_matrix</a></li><li><a href="global.html#transpose">transpose</a></li><li><a href="global.html#unroll_matrix_to_list">unroll_matrix_to_list</a></li><li><a href="global.html#vec3_to_se2_mat">vec3_to_se2_mat</a></li><li><a href="global.html#vec3_to_so3_mat">vec3_to_so3_mat</a></li><li><a href="global.html#vec6_to_se3_mat">vec6_to_se3_mat</a></li><li><a href="global.html#vec6_to_so3_and_v">vec6_to_so3_and_v</a></li><li><a href="global.html#vect_a_minus_b">vect_a_minus_b</a></li><li><a href="global.html#vect_max_abs_x_less_eps">vect_max_abs_x_less_eps</a></li><li><a href="global.html#vect_x_pluseq_ag">vect_x_pluseq_ag</a></li><li><a href="global.html#visualize_robot">visualize_robot</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Sun Sep 01 2024 17:05:37 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
