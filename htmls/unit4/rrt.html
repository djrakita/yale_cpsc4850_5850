<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Yale CPSC 4850/5850 - RRT</title>
    <script src="../../js/setup/setup_mathjax.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script type="importmap">
        {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/": "https://unpkg.com/three@0.160.0/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import {ThreeEngine} from '../js/utils/utils_three.js'
    import {CircleWorldFeasibilityChecker} from "../js/utils/utils_continuous_planning.js";
    import {get_default_lil_gui} from "../js/utils/utils_three.js";
    import {refresh_displays} from "../js/utils/utils_three.js";
    import {frobenius_norm_matrix, sub_matrix_matrix} from "../js/utils/utils_math.js";
    import {is_edge_feasible} from "../js/utils/utils_continuous_planning.js";
    import {TransformGizmoEngine} from "../js/utils/utils_transform_gizmo.js";
    import {unroll_matrix_to_list} from "../js/utils/utils_math.js";

    let engine = ThreeEngine.new_default_2d();
    let p = new CircleWorldFeasibilityChecker();
    let max_num_steps = 500;

    // RRT Node class
    class RRTNode {
        constructor(position, parent = null) {
            this.position = position; // [x, y]
            this.parent = parent;
            this.children = [];
            if (parent) {
                parent.children.push(this);
            }
        }
    }

    // RRT Algorithm Implementation
    class RRT {
        constructor(start, goal, stepSize = 0.3, goalBias = 0.1) {
            this.start = start;
            this.goal = goal;
            this.stepSize = stepSize;
            this.goalBias = goalBias;
            this.nodes = [new RRTNode(start)];
            this.goalReached = false;
            this.goalNode = null;
            this.path = [];
        }

        findNearestNode(point) {
            let minDist = Infinity;
            let nearest = null;

            for (let node of this.nodes) {
                let dist = this.distance(node.position, point);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = node;
                }
            }
            return nearest;
        }

        distance(a, b) {
            return frobenius_norm_matrix(sub_matrix_matrix(a, b));
        }

        steer(from, to, stepSize) {
            let direction = sub_matrix_matrix(to, from);
            let dist = frobenius_norm_matrix(direction);

            if (dist <= stepSize) {
                return to;
            }

            // Normalize direction and multiply by step size
            let normalizedDir = [direction[0] / dist, direction[1] / dist];
            return [from[0] + normalizedDir[0] * stepSize, from[1] + normalizedDir[1] * stepSize];
        }

        samplePoint() {
            // Goal bias: sometimes sample the goal directly
            if (Math.random() < this.goalBias) {
                return this.goal.slice(); // Return copy of goal
            }

            // Random sampling within bounds
            let rx = p.x_min + (p.x_max - p.x_min) * Math.random();
            let ry = p.y_min + (p.y_max - p.y_min) * Math.random();
            return [rx, ry];
        }

        extend() {
            // Sample random point
            let randomPoint = this.samplePoint();

            // Find nearest node
            let nearestNode = this.findNearestNode(randomPoint);

            // Steer towards random point
            let newPoint = this.steer(nearestNode.position, randomPoint, this.stepSize);

            // Check if new point is feasible and edge is valid
            if (p.is_feasible(newPoint) && is_edge_feasible(nearestNode.position, newPoint, p)) {
                let newNode = new RRTNode(newPoint, nearestNode);
                this.nodes.push(newNode);

                // Check if we've reached the goal
                if (this.distance(newPoint, this.goal) <= this.stepSize &&
                    is_edge_feasible(newPoint, this.goal, p)) {
                    this.goalNode = newNode;
                    this.goalReached = true;
                    this.computePath();
                }

                return {
                    success: true,
                    sample: randomPoint,
                    nearest: nearestNode.position,
                    newNode: newPoint
                };
            }

            return {
                success: false,
                sample: randomPoint,
                nearest: nearestNode.position,
                newNode: null
            };
        }

        computePath() {
            if (!this.goalReached) return;

            this.path = [];
            let current = this.goalNode;

            while (current) {
                this.path.unshift(current.position);
                current = current.parent;
            }

            // Add goal point to complete the path
            if (this.path.length > 0) {
                this.path.push(this.goal);
            }
        }
    }

    let rrt = null;
    let all_steps = [];
    let lastStartPos = null;
    let lastGoalPos = null;

    let actions = {
        compute_all_steps: function() {
            let start_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(0)[1]);
            let goal_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(1)[1]);

            rrt = new RRT(start_point, goal_point, settings.step_size, settings.goal_bias);
            all_steps = [];

            for (let i = 0; i < max_num_steps; i++) {
                let result = rrt.extend();
                all_steps.push(result);

                if (rrt.goalReached) {
                    break;
                }
            }

            lastStartPos = start_point.slice();
            lastGoalPos = goal_point.slice();
        },
        increment_step: function() {
            settings.step += 1;
            if (settings.step >= all_steps.length) {
                settings.step = all_steps.length - 1;
            }
            refresh_displays(gui);
        },
        decrement_step: function() {
            settings.step -= 1;
            if (settings.step < 0) {
                settings.step = 0;
            }
            refresh_displays(gui);
        },
        toggle_play: function() {
            settings.is_playing = !settings.is_playing;
        },
        stop: function() {
            settings.is_playing = false;
        }
    }

    let settings = {
        step_size: 0.3,
        goal_bias: 0.1,
        step: 0,
        is_playing: false,
        show_tree: true,
        show_path: true
    }

    let gui = get_default_lil_gui();
    gui.add(settings, 'step_size', 0.1, 1.0).name('step size').onFinishChange(actions.compute_all_steps);
    gui.add(settings, 'goal_bias', 0.0, 1.0).name('goal bias').onFinishChange(actions.compute_all_steps);
    gui.add(settings, 'show_tree').name('show RRT tree');
    gui.add(settings, 'show_path').name('show solution path');
    gui.add(settings, 'step', 0, max_num_steps, 1).onChange(actions.stop);
    gui.add(actions, 'increment_step').onChange(actions.stop);
    gui.add(actions, 'decrement_step').onChange(actions.stop);
    gui.add(actions, 'toggle_play').name('play/stop');
    gui.add(actions, 'compute_all_steps').name('recompute');

    let tge = new TransformGizmoEngine(engine);
    tge.add_gizmo_SO2_matrix_and_position(engine, undefined, [-3.0, 0.0], 0.3);
    tge.add_gizmo_SO2_matrix_and_position(engine, undefined, [3.0, 0.0], 0.3);

    actions.compute_all_steps();

    engine.animation_loop(() => {
        p.draw(engine);

        let start_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(0)[1]);
        let goal_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(1)[1]);

        // Check if start or goal has moved
        let startMoved = !lastStartPos || frobenius_norm_matrix(sub_matrix_matrix(start_point, lastStartPos)) > 0.01;
        let goalMoved = !lastGoalPos || frobenius_norm_matrix(sub_matrix_matrix(goal_point, lastGoalPos)) > 0.01;

        if (startMoved || goalMoved) {
            actions.compute_all_steps();
        }

        // Draw start and goal points
        engine.draw_debug_sphere([start_point[0], start_point[1], 6.0], 0.08, 0x00FF00); // Green start
        engine.draw_debug_sphere([goal_point[0], goal_point[1], 6.0], 0.08, 0xFF0000); // Red goal

        if (!rrt || all_steps.length === 0) return;

        // Draw RRT tree up to current step
        if (settings.show_tree) {
            for (let i = 0; i <= Math.min(settings.step, all_steps.length - 1); i++) {
                let step = all_steps[i];

                if (step.success && step.newNode) {
                    // Draw node
                    if (i === settings.step) {
                        // Current step - highlight in yellow
                        engine.draw_debug_sphere([step.newNode[0], step.newNode[1], 6.0], 0.06, 0xFFFF00);
                        // Draw line from nearest to new node in yellow
                        engine.draw_debug_line(
                            [step.nearest[0], step.nearest[1], 6.0],
                            [step.newNode[0], step.newNode[1], 6.0],
                            false, 0.05, 0xFFFF00
                        );
                    } else {
                        // Previous steps - blue nodes and gray lines
                        engine.draw_debug_sphere([step.newNode[0], step.newNode[1], 6.0], 0.04, 0x0066FF);
                        engine.draw_debug_line(
                            [step.nearest[0], step.nearest[1], 6.0],
                            [step.newNode[0], step.newNode[1], 6.0],
                            false, 0.02, 0x666666
                        );
                    }
                }
            }

            // Draw sample point only for current step
            let currentStep = all_steps[settings.step];
            if (currentStep && currentStep.sample) {
                engine.draw_debug_sphere([currentStep.sample[0], currentStep.sample[1], 6.1], 0.03, 0x9966FF);

                // Draw line from nearest to sample in yellow for current step
                if (currentStep.nearest) {
                    engine.draw_debug_line(
                        [currentStep.nearest[0], currentStep.nearest[1], 6.05],
                        [currentStep.sample[0], currentStep.sample[1], 6.05],
                        false, 0.01, 0x222222
                    );
                }
            }
        }

        // Draw solution path if found and we're past the solution step
        let solutionFoundAtStep = -1;
        if (rrt.goalReached) {
            // Find the step where the solution was found
            for (let i = 0; i < all_steps.length; i++) {
                if (all_steps[i].success && all_steps[i].newNode) {
                    // Check if this step connected to the goal
                    let dist = frobenius_norm_matrix(sub_matrix_matrix(all_steps[i].newNode, goal_point));
                    if (dist <= settings.step_size && is_edge_feasible(all_steps[i].newNode, goal_point, p)) {
                        solutionFoundAtStep = i;
                        break;
                    }
                }
            }
        }

        if (settings.show_path && rrt.goalReached && rrt.path.length > 0 &&
            solutionFoundAtStep >= 0 && settings.step >= solutionFoundAtStep) {

            for (let i = 0; i < rrt.path.length - 1; i++) {
                let from = [rrt.path[i][0], rrt.path[i][1], 6.2];
                let to = [rrt.path[i + 1][0], rrt.path[i + 1][1], 6.2];
                engine.draw_debug_line(from, to, false, 0.08, 0xFF00FF); // Magenta path
            }
        }

        // Auto-play functionality
        if (settings.is_playing) {
            if (engine.frame_idx % 15 === 0) {
                settings.step += 1;
                if (settings.step >= all_steps.length) {
                    settings.step = 0;
                    actions.compute_all_steps(); // Restart
                }
            }
        }

        refresh_displays(gui);
    });

</script>
</body>
</html>