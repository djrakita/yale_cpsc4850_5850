<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Yale CPSC 4850/5850 - RRT-Connect</title>
    <script src="../../js/setup/setup_mathjax.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script type="importmap">
        {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/": "https://unpkg.com/three@0.160.0/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import {ThreeEngine} from '../js/utils/utils_three.js'
    import {CircleWorldFeasibilityChecker} from "../js/utils/utils_continuous_planning.js";
    import {get_default_lil_gui} from "../js/utils/utils_three.js";
    import {refresh_displays} from "../js/utils/utils_three.js";
    import {frobenius_norm_matrix, sub_matrix_matrix} from "../js/utils/utils_math.js";
    import {is_edge_feasible} from "../js/utils/utils_continuous_planning.js";
    import {TransformGizmoEngine} from "../js/utils/utils_transform_gizmo.js";
    import {unroll_matrix_to_list} from "../js/utils/utils_math.js";

    let engine = ThreeEngine.new_default_2d();
    let p = new CircleWorldFeasibilityChecker();
    let max_num_steps = 1000;

    // RRT Node class
    class RRTNode {
        constructor(position, parent = null) {
            this.position = position; // [x, y]
            this.parent = parent;
            this.children = [];
            if (parent) {
                parent.children.push(this);
            }
        }
    }

    // RRT Tree class
    class RRTTree {
        constructor(rootPosition, treeId) {
            this.nodes = [new RRTNode(rootPosition)];
            this.treeId = treeId; // 1 for start tree, 2 for goal tree
        }

        findNearestNode(point) {
            let minDist = Infinity;
            let nearest = null;

            for (let node of this.nodes) {
                let dist = this.distance(node.position, point);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = node;
                }
            }
            return nearest;
        }

        distance(a, b) {
            return frobenius_norm_matrix(sub_matrix_matrix(a, b));
        }

        addNode(position, parent) {
            let newNode = new RRTNode(position, parent);
            this.nodes.push(newNode);
            return newNode;
        }

        get numVertices() {
            return this.nodes.length;
        }
    }

    // Step types for visualization
    const StepType = {
        SAMPLE: 'sample',
        EXTEND_TO_SAMPLE: 'extend_to_sample',
        EXTEND_SINGLE: 'extend_single',
        CONNECT_TO_OTHER_TREE: 'connect_to_other_tree',
        CONNECT_SINGLE: 'connect_single',
        CONNECTION_SUCCESS: 'connection_success'
    };

    // RRT-Connect Algorithm Implementation
    class RRTConnect {
        constructor(start, goal, stepSize = 0.3) {
            this.start = start;
            this.goal = goal;
            this.stepSize = stepSize;
            this.tree1 = new RRTTree(start, 1); // Start tree
            this.tree2 = new RRTTree(goal, 2);  // Goal tree
            this.connected = false;
            this.connectionPoint1 = null;
            this.connectionPoint2 = null;
            this.path = [];
            this.allSteps = [];
        }

        samplePoint() {
            // Random sampling within bounds
            let rx = p.x_min + (p.x_max - p.x_min) * Math.random();
            let ry = p.y_min + (p.y_max - p.y_min) * Math.random();
            return [rx, ry];
        }

        distance(a, b) {
            return frobenius_norm_matrix(sub_matrix_matrix(a, b));
        }

        // Generate all steps for the algorithm
        generateAllSteps() {
            this.allSteps = [];
            let iterationCount = 0;

            while (!this.connected && iterationCount < max_num_steps / 10) {
                iterationCount++;

                // Determine which tree to extend (smaller one first)
                let activeTree, passiveTree;
                if (this.tree1.numVertices <= this.tree2.numVertices) {
                    activeTree = this.tree1;
                    passiveTree = this.tree2;
                } else {
                    activeTree = this.tree2;
                    passiveTree = this.tree1;
                }

                // Step 1: Sample random point
                let sample = this.samplePoint();
                this.allSteps.push({
                    type: StepType.SAMPLE,
                    sample: sample.slice(),
                    activeTreeId: activeTree.treeId,
                    tree1Size: this.tree1.numVertices,
                    tree2Size: this.tree2.numVertices
                });

                // Step 2: Find nearest node in active tree
                let nearestInActive = activeTree.findNearestNode(sample);

                // Step 3: try_connect from nearest to sample
                let connectResult = this.tryConnectWithSteps(nearestInActive, sample, activeTree);

                if (connectResult.steps.length === 0) {
                    // Failed immediately
                    this.allSteps.push({
                        type: StepType.EXTEND_TO_SAMPLE,
                        success: false,
                        sample: sample.slice(),
                        nearest: nearestInActive.position.slice(),
                        activeTreeId: activeTree.treeId,
                        reason: 'collision'
                    });
                    continue;
                }

                // Add all the connection steps
                connectResult.steps.forEach(step => this.allSteps.push(step));
                let lastAddedNode = connectResult.lastNode;

                // Step 4: Find nearest in passive tree to the last added node
                let nearestInPassive = passiveTree.findNearestNode(lastAddedNode.position);

                this.allSteps.push({
                    type: StepType.CONNECT_TO_OTHER_TREE,
                    from: lastAddedNode.position.slice(),
                    to: nearestInPassive.position.slice(),
                    activeTreeId: activeTree.treeId,
                    passiveTreeId: passiveTree.treeId
                });

                // Step 5: try_connect from last added node toward nearest in passive tree
                let connectResult2 = this.tryConnectWithSteps(lastAddedNode, nearestInPassive.position, activeTree);

                if (connectResult2.steps.length > 0) {
                    connectResult2.steps.forEach(step => this.allSteps.push(step));

                    // Check if we've connected the trees
                    let finalNode = connectResult2.lastNode;
                    let distToPassive = this.distance(finalNode.position, nearestInPassive.position);

                    if (distToPassive <= this.stepSize &&
                        is_edge_feasible(finalNode.position, nearestInPassive.position, p)) {

                        this.connected = true;
                        this.connectionPoint1 = finalNode;
                        this.connectionPoint2 = nearestInPassive;

                        this.allSteps.push({
                            type: StepType.CONNECTION_SUCCESS,
                            point1: finalNode.position.slice(),
                            point2: nearestInPassive.position.slice(),
                            tree1Id: activeTree.treeId,
                            tree2Id: passiveTree.treeId
                        });

                        this.computePath();
                        break;
                    }
                }
            }
        }

        tryConnectWithSteps(startVertex, targetState, tree) {
            let steps = [];
            let currentVertex = startVertex;
            let direction = sub_matrix_matrix(targetState, currentVertex.position);
            let distance = frobenius_norm_matrix(direction);

            if (distance === 0) {
                return { steps: [], lastNode: currentVertex };
            }

            let normalizedDirection = [direction[0] / distance, direction[1] / distance];

            while (true) {
                let candidateState = [
                    currentVertex.position[0] + this.stepSize * normalizedDirection[0],
                    currentVertex.position[1] + this.stepSize * normalizedDirection[1]
                ];

                // Check if candidate is feasible and edge is valid
                if (p.is_feasible(candidateState) &&
                    is_edge_feasible(currentVertex.position, candidateState, p)) {

                    let addedVertex = tree.addNode(candidateState, currentVertex);

                    steps.push({
                        type: StepType.EXTEND_SINGLE,
                        from: currentVertex.position.slice(),
                        to: candidateState.slice(),
                        treeId: tree.treeId,
                        success: true
                    });

                    // Check if we're close enough to the target
                    let distToTarget = this.distance(candidateState, targetState);
                    if (distToTarget <= this.stepSize) {
                        // Try to connect directly to target
                        if (is_edge_feasible(candidateState, targetState, p)) {
                            let finalVertex = tree.addNode(targetState, addedVertex);
                            steps.push({
                                type: StepType.EXTEND_SINGLE,
                                from: candidateState.slice(),
                                to: targetState.slice(),
                                treeId: tree.treeId,
                                success: true,
                                reachedTarget: true
                            });
                            return { steps: steps, lastNode: finalVertex };
                        } else {
                            return { steps: steps, lastNode: addedVertex };
                        }
                    } else {
                        currentVertex = addedVertex;
                    }
                } else {
                    steps.push({
                        type: StepType.EXTEND_SINGLE,
                        from: currentVertex.position.slice(),
                        to: candidateState.slice(),
                        treeId: tree.treeId,
                        success: false,
                        reason: 'collision'
                    });
                    return { steps: steps, lastNode: currentVertex };
                }
            }
        }

        computePath() {
            if (!this.connected) return;

            this.path = [];

            // Path from start to connection point
            let current = this.connectionPoint1;
            let pathToConnection = [];
            while (current) {
                pathToConnection.unshift(current.position);
                current = current.parent;
            }

            // Path from connection point to goal
            current = this.connectionPoint2;
            let pathFromConnection = [];
            while (current) {
                pathFromConnection.push(current.position);
                current = current.parent;
            }

            // Determine correct order based on which tree the connection points belong to
            if (this.tree1.nodes.includes(this.connectionPoint1)) {
                // Connection point 1 is in start tree, connection point 2 is in goal tree
                this.path = pathToConnection.concat(pathFromConnection);
            } else {
                // Connection point 1 is in goal tree, connection point 2 is in start tree
                this.path = pathFromConnection.reverse().concat(pathToConnection.reverse());
            }
        }
    }

    let rrtConnect = null;
    let lastStartPos = null;
    let lastGoalPos = null;

    let actions = {
        compute_all_steps: function() {
            let start_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(0)[1]);
            let goal_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(1)[1]);

            rrtConnect = new RRTConnect(start_point, goal_point, settings.step_size);
            rrtConnect.generateAllSteps();

            lastStartPos = start_point.slice();
            lastGoalPos = goal_point.slice();

            // Don't reset step when recomputing
        },
        increment_step: function() {
            settings.step += 1;
            if (settings.step > 500) {
                settings.step = 500;
            }
            refresh_displays(gui);
        },
        decrement_step: function() {
            settings.step -= 1;
            if (settings.step < 0) {
                settings.step = 0;
            }
            refresh_displays(gui);
        },
        toggle_play: function() {
            settings.is_playing = !settings.is_playing;
        },
        stop: function() {
            settings.is_playing = false;
        }
    }

    let settings = {
        step_size: 0.3,
        step: 0,
        is_playing: false,
        show_trees: true,
        show_path: true,
        show_step_details: true
    }

    let gui = get_default_lil_gui();
    gui.add(settings, 'step_size', 0.1, 1.0).name('step size').onFinishChange(actions.compute_all_steps);
    gui.add(settings, 'show_trees').name('show RRT trees');
    gui.add(settings, 'show_path').name('show solution path');
    gui.add(settings, 'show_step_details').name('show step details');
    gui.add(settings, 'step', 0, 500, 1).onChange(actions.stop);
    gui.add(actions, 'increment_step').onChange(actions.stop);
    gui.add(actions, 'decrement_step').onChange(actions.stop);
    gui.add(actions, 'toggle_play').name('play/stop');
    gui.add(actions, 'compute_all_steps').name('recompute');

    let tge = new TransformGizmoEngine(engine);
    tge.add_gizmo_SO2_matrix_and_position(engine, undefined, [-3.0, 0.0], 0.3);
    tge.add_gizmo_SO2_matrix_and_position(engine, undefined, [3.0, 0.0], 0.3);

    actions.compute_all_steps();

    engine.animation_loop(() => {
        p.draw(engine);

        let start_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(0)[1]);
        let goal_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(1)[1]);

        // Check if start or goal has moved
        let startMoved = !lastStartPos || frobenius_norm_matrix(sub_matrix_matrix(start_point, lastStartPos)) > 0.01;
        let goalMoved = !lastGoalPos || frobenius_norm_matrix(sub_matrix_matrix(goal_point, lastGoalPos)) > 0.01;

        if (startMoved || goalMoved) {
            actions.compute_all_steps();
        }

        // Draw start and goal points
        engine.draw_debug_sphere([start_point[0], start_point[1], 6.0], 0.08, 0x00FF00); // Green start
        engine.draw_debug_sphere([goal_point[0], goal_point[1], 6.0], 0.08, 0xFF0000); // Red goal

        if (!rrtConnect || rrtConnect.allSteps.length === 0) return;

        // Draw trees progressively up to current step
        if (settings.show_trees) {
            // Collect all nodes that should be visible at current step
            let visibleTree1Nodes = [rrtConnect.tree1.nodes[0]]; // Always show root
            let visibleTree2Nodes = [rrtConnect.tree2.nodes[0]]; // Always show root

            // Go through all steps up to current step and collect added nodes
            for (let i = 0; i <= Math.min(settings.step, rrtConnect.allSteps.length - 1); i++) {
                let step = rrtConnect.allSteps[i];

                if (step.type === StepType.EXTEND_SINGLE && step.success) {
                    // Find the node that was added in this step
                    let targetTree = step.treeId === 1 ? rrtConnect.tree1 : rrtConnect.tree2;
                    let visibleNodes = step.treeId === 1 ? visibleTree1Nodes : visibleTree2Nodes;

                    // Find the node with this "to" position that's not already in visible nodes
                    for (let node of targetTree.nodes) {
                        let nodeInVisible = visibleNodes.some(vNode =>
                            Math.abs(vNode.position[0] - node.position[0]) < 0.001 &&
                            Math.abs(vNode.position[1] - node.position[1]) < 0.001
                        );

                        if (!nodeInVisible &&
                            Math.abs(node.position[0] - step.to[0]) < 0.001 &&
                            Math.abs(node.position[1] - step.to[1]) < 0.001) {
                            visibleNodes.push(node);
                            break;
                        }
                    }
                }
            }

            // Draw start tree (tree1) in blue - only visible nodes
            for (let node of visibleTree1Nodes) {
                if (node.parent && visibleTree1Nodes.includes(node.parent)) {
                    engine.draw_debug_line(
                        [node.parent.position[0], node.parent.position[1], 6.0],
                        [node.position[0], node.position[1], 6.0],
                        false, 0.02, 0x0066FF
                    );
                }
                engine.draw_debug_sphere([node.position[0], node.position[1], 6.0], 0.03, 0x0066FF);
            }

            // Draw goal tree (tree2) in orange - only visible nodes
            for (let node of visibleTree2Nodes) {
                if (node.parent && visibleTree2Nodes.includes(node.parent)) {
                    engine.draw_debug_line(
                        [node.parent.position[0], node.parent.position[1], 6.0],
                        [node.position[0], node.position[1], 6.0],
                        false, 0.02, 0xFF6600
                    );
                }
                engine.draw_debug_sphere([node.position[0], node.position[1], 6.0], 0.03, 0xFF6600);
            }
        }

        // Visualize current step
        if (settings.show_step_details && rrtConnect && settings.step < rrtConnect.allSteps.length) {
            let currentStep = rrtConnect.allSteps[settings.step];

            switch (currentStep.type) {
                case StepType.SAMPLE:
                    // Draw sample point in purple
                    engine.draw_debug_sphere([currentStep.sample[0], currentStep.sample[1], 6.1], 0.05, 0x9966FF);
                    break;

                case StepType.EXTEND_TO_SAMPLE:
                    if (!currentStep.success) {
                        // Draw failed attempt in red
                        engine.draw_debug_line(
                            [currentStep.nearest[0], currentStep.nearest[1], 6.05],
                            [currentStep.sample[0], currentStep.sample[1], 6.05],
                            false, 0.03, 0xFF0000
                        );
                    }
                    break;

                case StepType.EXTEND_SINGLE:
                    if (currentStep.success) {
                        // Draw successful extension in bright yellow
                        engine.draw_debug_line(
                            [currentStep.from[0], currentStep.from[1], 6.05],
                            [currentStep.to[0], currentStep.to[1], 6.05],
                            false, 0.04, 0xFFFF00
                        );
                        engine.draw_debug_sphere([currentStep.to[0], currentStep.to[1], 6.05], 0.05, 0xFFFF00);
                    } else {
                        // Draw failed extension in red
                        engine.draw_debug_line(
                            [currentStep.from[0], currentStep.from[1], 6.05],
                            [currentStep.to[0], currentStep.to[1], 6.05],
                            false, 0.03, 0xFF0000
                        );
                    }
                    break;

                case StepType.CONNECT_TO_OTHER_TREE:
                    // Draw connection attempt line in cyan
                    engine.draw_debug_line(
                        [currentStep.from[0], currentStep.from[1], 6.05],
                        [currentStep.to[0], currentStep.to[1], 6.05],
                        false, 0.03, 0x00FFFF
                    );
                    break;

                case StepType.CONNECTION_SUCCESS:
                    // Draw successful connection in bright green
                    engine.draw_debug_line(
                        [currentStep.point1[0], currentStep.point1[1], 6.1],
                        [currentStep.point2[0], currentStep.point2[1], 6.1],
                        false, 0.06, 0x00FF00
                    );
                    break;
            }
        }

        // Draw solution path if found
        if (settings.show_path && rrtConnect.connected && rrtConnect.path.length > 0) {
            // Check if we've reached the connection success step
            let connectionStep = -1;
            for (let i = 0; i < rrtConnect.allSteps.length; i++) {
                if (rrtConnect.allSteps[i].type === StepType.CONNECTION_SUCCESS) {
                    connectionStep = i;
                    break;
                }
            }

            if (connectionStep >= 0 && settings.step >= connectionStep) {
                for (let i = 0; i < rrtConnect.path.length - 1; i++) {
                    let from = [rrtConnect.path[i][0], rrtConnect.path[i][1], 6.2];
                    let to = [rrtConnect.path[i + 1][0], rrtConnect.path[i + 1][1], 6.2];
                    engine.draw_debug_line(from, to, false, 0.08, 0xFF00FF); // Magenta path
                }
            }
        }

        // Auto-play functionality
        if (settings.is_playing) {
            if (engine.frame_idx % 20 === 0) {
                settings.step += 1;
                if (settings.step > 500) {
                    settings.step = 0;
                    actions.compute_all_steps(); // Restart
                }
            }
        }

        refresh_displays(gui);
    });

</script>
</body>
</html>