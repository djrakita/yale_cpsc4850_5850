<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Yale CPSC 4850/5850 - RRT-Connect</title>
    <script src="../../js/setup/setup_mathjax.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script type="importmap">
        {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/": "https://unpkg.com/three@0.160.0/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import {ThreeEngine} from '../js/utils/utils_three.js';
    import {CircleWorldFeasibilityChecker, is_edge_feasible} from "../js/utils/utils_continuous_planning.js";
    import {get_default_lil_gui, refresh_displays} from "../js/utils/utils_three.js";
    import {frobenius_norm_matrix, sub_matrix_matrix} from "../js/utils/utils_math.js";
    import {TransformGizmoEngine} from "../js/utils/utils_transform_gizmo.js";
    import {unroll_matrix_to_list} from "../js/utils/utils_math.js";

    // --- Scene/world setup ---
    let engine = ThreeEngine.new_default_2d();
    let p = new CircleWorldFeasibilityChecker();
    let max_num_steps = 500;

    // --- Utility primitives ---
    class Node {
        constructor(position, parent = null) {
            this.position = position; // [x, y]
            this.parent = parent;
            this.children = [];
            if (parent) parent.children.push(this);
        }
    }

    // RRT-Connect extend return codes
    const TRAPPED = 0, ADVANCED = 1, REACHED = 2;

    // --- RRT-Connect core ---
    class RRTConnect {
        constructor(start, goal, stepSize = 0.3, goalBias = 0.1) {
            this.stepSize = stepSize;
            this.goalBias = goalBias;

            // Persistent trees: start side and goal side
            this.treeStart = { root: new Node(start), nodes: [] };
            this.treeGoal  = { root: new Node(goal),  nodes: [] };
            this.treeStart.nodes.push(this.treeStart.root);
            this.treeGoal.nodes.push(this.treeGoal.root);

            // Results
            this.metA = null; // meeting node in tree A
            this.metB = null; // meeting node in tree B
            this.path = [];
            this.connected = false;
        }

        // Distance in R^2 using provided helpers
        distance(a, b) {
            return frobenius_norm_matrix(sub_matrix_matrix(a, b));
        }

        steer(from, to, stepSize) {
            let d = sub_matrix_matrix(to, from);
            let dist = frobenius_norm_matrix(d);
            if (dist <= stepSize) return to.slice();
            let nx = d[0] / dist, ny = d[1] / dist;
            return [from[0] + nx * stepSize, from[1] + ny * stepSize];
        }

        sample(goal) {
            if (Math.random() < this.goalBias) return goal.slice();
            let rx = p.x_min + (p.x_max - p.x_min) * Math.random();
            let ry = p.y_min + (p.y_max - p.y_min) * Math.random();
            return [rx, ry];
        }

        nearest(tree, point) {
            let best = null, bestd = Infinity;
            for (let n of tree.nodes) {
                let d = this.distance(n.position, point);
                if (d < bestd) { bestd = d; best = n; }
            }
            return best;
        }

        // Try to extend a tree by one step toward q_target.
        // Returns {code, from: Node, to: Node|null}
        extendOnce(tree, q_target) {
            let q_near = this.nearest(tree, q_target);
            let q_new = this.steer(q_near.position, q_target, this.stepSize);
            if (!p.is_feasible(q_new) || !is_edge_feasible(q_near.position, q_new, p)) {
                return { code: TRAPPED, from: q_near, to: null };
            }
            let newNode = new Node(q_new, q_near);
            tree.nodes.push(newNode);
            let reached = (this.distance(q_new, q_target) < 1e-6);
            return { code: reached ? REACHED : ADVANCED, from: q_near, to: newNode };
        }

        // CONNECT(T, q): keep extending toward q until trapped or reached
        // Returns {code, segments: [ [fromPos,toPos], ... ], lastNode}
        connect(tree, q) {
            let segments = [];
            let lastNode = null;
            while (true) {
                let r = this.extendOnce(tree, q);
                if (r.code === TRAPPED) {
                    return { code: TRAPPED, segments, lastNode };
                }
                // record the added segment
                segments.push([r.from.position, r.to.position]);
                lastNode = r.to;
                if (r.code === REACHED) {
                    return { code: REACHED, segments, lastNode };
                }
                // else ADVANCED: loop and keep going toward q
            }
        }

        // One outer RRT-Connect iteration; tries to grow Ta toward a sample and then CONNECT Tb
        // Returns a rich step object for visualization & logging.
        iterate(stepIdx, Ta, Tb) {
            // 1) sample
            const q_rand = this.sample(Tb.root.position);
            // 2) Extend Ta toward q_rand by ONE step
            const q_near = this.nearest(Ta, q_rand);
            const q_new  = this.steer(q_near.position, q_rand, this.stepSize);

            let extended = false;
            let newNodeA = null;
            if (p.is_feasible(q_new) && is_edge_feasible(q_near.position, q_new, p)) {
                newNodeA = new Node(q_new, q_near);
                Ta.nodes.push(newNodeA);
                extended = true;
            }

            // 3) If we advanced, try to CONNECT the other tree Tb toward q_new
            let connectRes = null;
            let status = 'TRAPPED';
            if (extended) {
                connectRes = this.connect(Tb, q_new);
                status = (connectRes.code === REACHED) ? 'REACHED' : (connectRes.code === TRAPPED ? 'TRAPPED' : 'ADVANCED');
            }

            // 4) If REACHED, we are connected: build final path
            if (extended && connectRes && connectRes.code === REACHED) {
                this.connected = true;
                this.metA = newNodeA;           // in Ta
                this.metB = connectRes.lastNode; // in Tb (reached q_new)
                this.buildPath();
            }

            return {
                step: stepIdx,
                q_rand,
                Ta_is_start: (Ta === this.treeStart),
                Tb_is_goal: (Tb === this.treeGoal),
                extended,
                q_near: q_near ? q_near.position : null,
                q_new: newNodeA ? newNodeA.position : null,
                connect_segments: connectRes ? connectRes.segments : [],
                status
            };
        }

        // Build a start->goal path via the meeting nodes
        buildPath() {
            if (!this.connected) return;

            // Helper to climb from node up to its root, returning a list of positions [node, ..., root]
            const climb = (node) => {
                const pts = [];
                let cur = node;
                while (cur) { pts.push(cur.position); cur = cur.parent; }
                return pts; // from meeting toward root
            };

            // Determine which roots our meeting nodes belong to
            const upA = climb(this.metA); // [meetA, ..., rootA]
            const upB = climb(this.metB); // [meetB, ..., rootB]

            // Identify which side is start vs goal by checking their ultimate roots
            const rootOf = (arr) => arr[arr.length - 1];
            const rootA = rootOf(upA);
            const rootB = rootOf(upB);

            const startRoot = this.treeStart.root.position;
            const goalRoot  = this.treeGoal.root.position;

            // Sanity: whichever chain ends at startRoot is the start-side chain
            let startChain = null, goalChain = null;
            let meetStart = null, meetGoal = null;
            if (Math.abs(rootA[0]-startRoot[0]) + Math.abs(rootA[1]-startRoot[1]) < 1e-9) {
                startChain = upA; meetStart = this.metA;
                goalChain  = upB; meetGoal  = this.metB;
            } else {
                startChain = upB; meetStart = this.metB;
                goalChain  = upA; meetGoal  = this.metA;
            }

            // startChain: [meet, ..., startRoot] => reverse to [startRoot, ..., meet]
            const startPart = startChain.slice().reverse();
            // goalChain: [meet, ..., goalRoot] => keep as [meet, ..., goalRoot]
            const goalPart = goalChain.slice();

            // Merge with a single meeting point (avoid duplicate)
            const merged = startPart.concat(goalPart.slice(1));
            this.path = merged;
        }
    }

    // --- Driver / Visualization state ---
    let rrtc = null;
    let all_steps = []; // rich step log
    let lastStartPos = null;
    let lastGoalPos = null;

    const actions = {
        compute_all_steps: function() {
            const start_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(0)[1]);
            const goal_point  = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(1)[1]);

            rrtc = new RRTConnect(start_point, goal_point, settings.step_size, settings.goal_bias);
            all_steps = [];

            // Alternate which tree is Ta each outer iteration
            let useStartFirst = true;
            for (let i = 0; i < max_num_steps; i++) {
                const Ta = useStartFirst ? rrtc.treeStart : rrtc.treeGoal;
                const Tb = useStartFirst ? rrtc.treeGoal  : rrtc.treeStart;
                const stepRec = rrtc.iterate(i, Ta, Tb);
                all_steps.push(stepRec);
                if (rrtc.connected) break;
                useStartFirst = !useStartFirst;
            }

            lastStartPos = start_point.slice();
            lastGoalPos  = goal_point.slice();
            settings.step = Math.min(settings.step, Math.max(all_steps.length - 1, 0));
        },
        increment_step: function() {
            settings.step += 1;
            if (settings.step >= all_steps.length) settings.step = all_steps.length - 1;
            refresh_displays(gui);
        },
        decrement_step: function() {
            settings.step -= 1;
            if (settings.step < 0) settings.step = 0;
            refresh_displays(gui);
        },
        toggle_play: function() { settings.is_playing = !settings.is_playing; },
        stop: function() { settings.is_playing = false; }
    };

    const settings = {
        step_size: 0.3,
        goal_bias: 0.1,
        step: 0,
        is_playing: false,
        show_trees: true,
        show_path: true,
        show_connect_segments: true
    };

    const gui = get_default_lil_gui();
    gui.add(settings, 'step_size', 0.1, 1.0).name('step size').onFinishChange(actions.compute_all_steps);
    gui.add(settings, 'goal_bias', 0.0, 1.0).name('goal bias').onFinishChange(actions.compute_all_steps);
    gui.add(settings, 'show_trees').name('show trees');
    gui.add(settings, 'show_connect_segments').name('show connect()');
    gui.add(settings, 'show_path').name('show solution path');
    gui.add(settings, 'step', 0, max_num_steps, 1).onChange(actions.stop);
    gui.add(actions, 'increment_step').onChange(actions.stop);
    gui.add(actions, 'decrement_step').onChange(actions.stop);
    gui.add(actions, 'toggle_play').name('play/stop');
    gui.add(actions, 'compute_all_steps').name('recompute');

    // --- Gizmos for start/goal ---
    let tge = new TransformGizmoEngine(engine);
    tge.add_gizmo_SO2_matrix_and_position(engine, undefined, [-3.0, 0.0], 0.3);
    tge.add_gizmo_SO2_matrix_and_position(engine, undefined, [ 3.0, 0.0], 0.3);

    actions.compute_all_steps();

    // --- Render loop ---
    engine.animation_loop(() => {
        p.draw(engine);

        const start_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(0)[1]);
        const goal_point  = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(1)[1]);

        // Recompute if start/goal moved
        const movedStart = !lastStartPos || frobenius_norm_matrix(sub_matrix_matrix(start_point, lastStartPos)) > 0.01;
        const movedGoal  = !lastGoalPos  || frobenius_norm_matrix(sub_matrix_matrix(goal_point,  lastGoalPos))  > 0.01;
        if (movedStart || movedGoal) actions.compute_all_steps();

        // Draw start (green) & goal (red)
        engine.draw_debug_sphere([start_point[0], start_point[1], 6.0], 0.08, 0x00ff00);
        engine.draw_debug_sphere([goal_point[0],  goal_point[1],  6.0], 0.08, 0xff0000);

        if (!rrtc || all_steps.length === 0) { refresh_displays(gui); return; }

        // Draw trees up to current step
        if (settings.show_trees) {
            // Helper to render a tree by walking parents (lightweight)
            const drawTree = (tree, colorNode, colorEdge) => {
                for (let n of tree.nodes) {
                    if (n.parent) {
                        engine.draw_debug_line([n.parent.position[0], n.parent.position[1], 6.0],
                            [n.position[0],       n.position[1],       6.0],
                            false, 0.02, colorEdge);
                    }
                    engine.draw_debug_sphere([n.position[0], n.position[1], 6.0], 0.035, colorNode);
                }
            };

            // Show both full trees grown so far (up to current step index)
            // Reconstruct partial trees by replaying the steps to current index
            const partialStart = { root: rrtc.treeStart.root, nodes: [rrtc.treeStart.root] };
            const partialGoal  = { root: rrtc.treeGoal.root,  nodes: [rrtc.treeGoal.root] };

            // Map from position key to nodes for quick parenting during partial rebuild
            const key = (p) => p[0].toFixed(5) + ',' + p[1].toFixed(5);
            const nodeMapStart = new Map([[key(partialStart.root.position), partialStart.root]]);
            const nodeMapGoal  = new Map([[key(partialGoal.root.position),  partialGoal.root]]);

            for (let i = 0; i <= Math.min(settings.step, all_steps.length - 1); i++) {
                const s = all_steps[i];
                if (!s.extended) continue;
                const isAStart = s.Ta_is_start;
                const parentMap = isAStart ? nodeMapStart : nodeMapGoal;
                const treePartial = isAStart ? partialStart : partialGoal;

                // ensure parent exists
                const pKey = key(s.q_near);
                let parentNode = parentMap.get(pKey);
                if (!parentNode) { parentNode = new Node(s.q_near, null); parentMap.set(pKey, parentNode); treePartial.nodes.push(parentNode); }
                // add child
                const childNode = new Node(s.q_new, parentNode);
                parentMap.set(key(s.q_new), childNode);
                treePartial.nodes.push(childNode);

                // add connect segments on the other tree as edges (lightweight visualization)
                if (settings.show_connect_segments && s.connect_segments) {
                    for (let seg of s.connect_segments) {
                        engine.draw_debug_line([seg[0][0], seg[0][1], 6.0], [seg[1][0], seg[1][1], 6.0], false, 0.02, 0xaaaa00);
                    }
                }
            }

            // Render partials (blue for start tree, orange-red for goal tree)
            drawTree(partialStart, 0x0066ff, 0x666666);
            drawTree(partialGoal,  0xff5500, 0x884444);

            // Highlight current iteration sample & attempt
            const cur = all_steps[settings.step];
            if (cur) {
                if (cur.q_rand) engine.draw_debug_sphere([cur.q_rand[0], cur.q_rand[1], 6.1], 0.03, 0x9966ff);
                if (cur.q_near && cur.q_new) {
                    engine.draw_debug_line([cur.q_near[0], cur.q_near[1], 6.1], [cur.q_new[0], cur.q_new[1], 6.1], false, 0.05, 0xffff00);
                    engine.draw_debug_sphere([cur.q_new[0], cur.q_new[1], 6.1], 0.05, 0xffff00);
                }
            }
        }

        // Draw final path once connected and current step is past the connection event
        if (settings.show_path && rrtc.connected) {
            // Find first step where status==REACHED
            let foundAt = all_steps.findIndex(s => s.status === 'REACHED');
            if (foundAt < 0) foundAt = all_steps.length - 1;
            if (settings.step >= foundAt && rrtc.path.length > 1) {
                for (let i = 0; i < rrtc.path.length - 1; i++) {
                    const a = rrtc.path[i], b = rrtc.path[i+1];
                    engine.draw_debug_line([a[0], a[1], 6.2], [b[0], b[1], 6.2], false, 0.08, 0xff00ff);
                }
            }
        }

        // Auto-play
        if (settings.is_playing) {
            if (engine.frame_idx % 15 === 0) {
                settings.step += 1;
                if (settings.step >= all_steps.length) {
                    settings.step = 0;
                    actions.compute_all_steps();
                }
            }
        }

        refresh_displays(gui);
    });
</script>
</body>
</html>