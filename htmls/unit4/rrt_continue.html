<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Yale CPSC 4850/5850 - RRT</title>
    <script src="../../js/setup/setup_mathjax.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script type="importmap">
        {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/": "https://unpkg.com/three@0.160.0/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import {ThreeEngine} from '../js/utils/utils_three.js'
    import {CircleWorldFeasibilityChecker} from "../js/utils/utils_continuous_planning.js";
    import {get_default_lil_gui} from "../js/utils/utils_three.js";
    import {refresh_displays} from "../js/utils/utils_three.js";
    import {frobenius_norm_matrix, sub_matrix_matrix} from "../js/utils/utils_math.js";
    import {is_edge_feasible} from "../js/utils/utils_continuous_planning.js";
    import {TransformGizmoEngine} from "../js/utils/utils_transform_gizmo.js";
    import {unroll_matrix_to_list} from "../js/utils/utils_math.js";

    let engine = ThreeEngine.new_default_2d();
    let p = new CircleWorldFeasibilityChecker();
    let max_num_steps = 2000;

    // RRT Node class
    class RRTNode {
        constructor(position, parent = null) {
            this.position = position; // [x, y]
            this.parent = parent;
            this.children = [];
            if (parent) {
                parent.children.push(this);
            }
        }
    }

    // RRT Algorithm Implementation
    class RRT {
        constructor(start, goal, stepSize = 0.3, goalBias = 0.1) {
            this.start = start;
            this.goal = goal;
            this.stepSize = stepSize;
            this.goalBias = goalBias;
            this.nodes = [new RRTNode(start)];
            this.goalNodes = []; // Store all nodes that reach the goal
            this.shortestPath = [];
            this.shortestPathLength = Infinity;
        }

        findNearestNode(point) {
            let minDist = Infinity;
            let nearest = null;

            for (let node of this.nodes) {
                let dist = this.distance(node.position, point);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = node;
                }
            }
            return nearest;
        }

        distance(a, b) {
            return frobenius_norm_matrix(sub_matrix_matrix(a, b));
        }

        steer(from, to, stepSize) {
            let direction = sub_matrix_matrix(to, from);
            let dist = frobenius_norm_matrix(direction);

            if (dist <= stepSize) {
                return to;
            }

            // Normalize direction and multiply by step size
            let normalizedDir = [direction[0] / dist, direction[1] / dist];
            return [from[0] + normalizedDir[0] * stepSize, from[1] + normalizedDir[1] * stepSize];
        }

        samplePoint() {
            // Goal bias: sometimes sample the goal directly
            if (Math.random() < this.goalBias) {
                return this.goal.slice(); // Return copy of goal
            }

            // Random sampling within bounds
            let rx = p.x_min + (p.x_max - p.x_min) * Math.random();
            let ry = p.y_min + (p.y_max - p.y_min) * Math.random();
            return [rx, ry];
        }

        computePathFromNode(goalNode) {
            let path = [];
            let current = goalNode;

            while (current) {
                path.unshift(current.position);
                current = current.parent;
            }

            // Add goal point to complete the path
            if (path.length > 0) {
                path.push(this.goal);
            }

            return path;
        }

        computePathLength(path) {
            let length = 0;
            for (let i = 0; i < path.length - 1; i++) {
                length += this.distance(path[i], path[i + 1]);
            }
            return length;
        }

        updateShortestPath() {
            let currentShortest = null;
            let currentShortestLength = Infinity;

            // Check all goal-reaching nodes for the shortest path
            for (let goalNode of this.goalNodes) {
                let path = this.computePathFromNode(goalNode);
                let pathLength = this.computePathLength(path);

                if (pathLength < currentShortestLength) {
                    currentShortestLength = pathLength;
                    currentShortest = path;
                }
            }

            if (currentShortest) {
                this.shortestPath = currentShortest;
                this.shortestPathLength = currentShortestLength;
            }
        }

        extend() {
            // Sample random point
            let randomPoint = this.samplePoint();

            // Find nearest node
            let nearestNode = this.findNearestNode(randomPoint);

            // Steer towards random point
            let newPoint = this.steer(nearestNode.position, randomPoint, this.stepSize);

            // Check if new point is feasible and edge is valid
            if (p.is_feasible(newPoint) && is_edge_feasible(nearestNode.position, newPoint, p)) {
                let newNode = new RRTNode(newPoint, nearestNode);
                this.nodes.push(newNode);

                let goalReached = false;
                // Check if we've reached the goal
                if (this.distance(newPoint, this.goal) <= this.stepSize &&
                    is_edge_feasible(newPoint, this.goal, p)) {
                    this.goalNodes.push(newNode);
                    this.updateShortestPath();
                    goalReached = true;
                }

                return {
                    success: true,
                    sample: randomPoint,
                    nearest: nearestNode.position,
                    newNode: newPoint,
                    goalReached: goalReached
                };
            }

            return {
                success: false,
                sample: randomPoint,
                nearest: nearestNode.position,
                newNode: null,
                goalReached: false
            };
        }

        hasFoundGoal() {
            return this.goalNodes.length > 0;
        }
    }

    let rrt = null;
    let all_steps = [];
    let lastStartPos = null;
    let lastGoalPos = null;

    let actions = {
        compute_all_steps: function() {
            let start_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(0)[1]);
            let goal_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(1)[1]);

            rrt = new RRT(start_point, goal_point, settings.step_size, settings.goal_bias);
            all_steps = [];

            // Continue for all steps regardless of whether goal is reached
            for (let i = 0; i < max_num_steps; i++) {
                let result = rrt.extend();
                all_steps.push(result);
            }

            lastStartPos = start_point.slice();
            lastGoalPos = goal_point.slice();
        },
        increment_step: function() {
            settings.step += 1;
            if (settings.step >= all_steps.length) {
                settings.step = all_steps.length - 1;
            }
            refresh_displays(gui);
        },
        decrement_step: function() {
            settings.step -= 1;
            if (settings.step < 0) {
                settings.step = 0;
            }
            refresh_displays(gui);
        },
        toggle_play: function() {
            settings.is_playing = !settings.is_playing;
        },
        stop: function() {
            settings.is_playing = false;
        }
    }

    let settings = {
        step_size: 0.3,
        goal_bias: 0.1,
        step: 0,
        is_playing: false,
        show_tree: true,
        show_path: true,
        shortest_path_length: 0
    }

    let gui = get_default_lil_gui();
    gui.add(settings, 'step_size', 0.1, 1.0).name('step size').onFinishChange(actions.compute_all_steps);
    gui.add(settings, 'goal_bias', 0.0, 1.0).name('goal bias').onFinishChange(actions.compute_all_steps);
    gui.add(settings, 'show_tree').name('show RRT tree');
    gui.add(settings, 'show_path').name('show solution path');
    gui.add(settings, 'shortest_path_length').name('shortest path length').disable();
    gui.add(settings, 'step', 0, max_num_steps, 1).onChange(actions.stop);
    gui.add(actions, 'increment_step').onChange(actions.stop);
    gui.add(actions, 'decrement_step').onChange(actions.stop);
    gui.add(actions, 'toggle_play').name('play/stop');
    gui.add(actions, 'compute_all_steps').name('recompute');

    let tge = new TransformGizmoEngine(engine);
    tge.add_gizmo_SO2_matrix_and_position(engine, undefined, [-3.0, 0.0], 0.3);
    tge.add_gizmo_SO2_matrix_and_position(engine, undefined, [3.0, 0.0], 0.3);

    actions.compute_all_steps();

    engine.animation_loop(() => {
        p.draw(engine);

        let start_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(0)[1]);
        let goal_point = unroll_matrix_to_list(tge.get_gizmo_pose_as_SO2_matrix_and_position(1)[1]);

        // Check if start or goal has moved
        let startMoved = !lastStartPos || frobenius_norm_matrix(sub_matrix_matrix(start_point, lastStartPos)) > 0.01;
        let goalMoved = !lastGoalPos || frobenius_norm_matrix(sub_matrix_matrix(goal_point, lastGoalPos)) > 0.01;

        if (startMoved || goalMoved) {
            actions.compute_all_steps();
        }

        // Draw start and goal points
        engine.draw_debug_sphere([start_point[0], start_point[1], 6.0], 0.08, 0x00FF00); // Green start
        engine.draw_debug_sphere([goal_point[0], goal_point[1], 6.0], 0.08, 0xFF0000); // Red goal

        if (!rrt || all_steps.length === 0) return;

        // Update shortest path length display based on current step
        let currentShortestLength = 0;
        for (let i = 0; i <= Math.min(settings.step, all_steps.length - 1); i++) {
            if (all_steps[i].goalReached && rrt.shortestPathLength < Infinity) {
                // Recompute shortest path up to current step
                let tempGoalNodes = [];
                for (let j = 0; j <= i; j++) {
                    if (all_steps[j].goalReached && all_steps[j].success) {
                        // Find the corresponding node in the RRT
                        for (let node of rrt.nodes) {
                            if (node.position[0] === all_steps[j].newNode[0] &&
                                node.position[1] === all_steps[j].newNode[1]) {
                                tempGoalNodes.push(node);
                                break;
                            }
                        }
                    }
                }

                // Find shortest among temp goal nodes
                let tempShortest = Infinity;
                for (let goalNode of tempGoalNodes) {
                    let path = rrt.computePathFromNode(goalNode);
                    let pathLength = rrt.computePathLength(path);
                    if (pathLength < tempShortest) {
                        tempShortest = pathLength;
                    }
                }
                if (tempShortest < Infinity) {
                    currentShortestLength = tempShortest;
                }
            }
        }
        settings.shortest_path_length = currentShortestLength.toFixed(2);

        // Draw RRT tree up to current step
        if (settings.show_tree) {
            for (let i = 0; i <= Math.min(settings.step, all_steps.length - 1); i++) {
                let step = all_steps[i];

                if (step.success && step.newNode) {
                    // Draw node
                    if (i === settings.step) {
                        // Current step - highlight in yellow
                        let nodeColor = step.goalReached ? 0xFF8800 : 0xFFFF00; // Orange if goal reached, yellow otherwise
                        engine.draw_debug_sphere([step.newNode[0], step.newNode[1], 6.0], 0.06, nodeColor);
                        // Draw line from nearest to new node in yellow
                        engine.draw_debug_line(
                            [step.nearest[0], step.nearest[1], 6.0],
                            [step.newNode[0], step.newNode[1], 6.0],
                            false, 0.05, 0xFFFF00
                        );
                    } else {
                        // Previous steps - blue nodes (orange if goal reached) and gray lines
                        let nodeColor = step.goalReached ? 0xFF6600 : 0x0066FF; // Changed to orange instead of red
                        engine.draw_debug_sphere([step.newNode[0], step.newNode[1], 6.0], 0.04, nodeColor);
                        engine.draw_debug_line(
                            [step.nearest[0], step.nearest[1], 6.0],
                            [step.newNode[0], step.newNode[1], 6.0],
                            false, 0.02, 0x666666
                        );
                    }
                }
            }

            // Draw sample point only for current step
            let currentStep = all_steps[settings.step];
            if (currentStep && currentStep.sample) {
                engine.draw_debug_sphere([currentStep.sample[0], currentStep.sample[1], 6.1], 0.03, 0x9966FF);

                // Draw line from nearest to sample in yellow for current step
                if (currentStep.nearest) {
                    engine.draw_debug_line(
                        [currentStep.nearest[0], currentStep.nearest[1], 6.05],
                        [currentStep.sample[0], currentStep.sample[1], 6.05],
                        false, 0.01, 0x222222
                    );
                }
            }
        }

        // Draw shortest solution path found so far
        if (settings.show_path && rrt.hasFoundGoal() && currentShortestLength > 0) {
            // Find the shortest path available up to the current step
            let bestPath = null;
            let bestLength = Infinity;

            for (let i = 0; i <= Math.min(settings.step, all_steps.length - 1); i++) {
                if (all_steps[i].goalReached && all_steps[i].success) {
                    // Find the corresponding node in the RRT
                    for (let node of rrt.nodes) {
                        if (node.position[0] === all_steps[i].newNode[0] &&
                            node.position[1] === all_steps[i].newNode[1]) {
                            let path = rrt.computePathFromNode(node);
                            let pathLength = rrt.computePathLength(path);
                            if (pathLength < bestLength) {
                                bestLength = pathLength;
                                bestPath = path;
                            }
                            break;
                        }
                    }
                }
            }

            if (bestPath && bestPath.length > 0) {
                for (let i = 0; i < bestPath.length - 1; i++) {
                    let from = [bestPath[i][0], bestPath[i][1], 6.2];
                    let to = [bestPath[i + 1][0], bestPath[i + 1][1], 6.2];
                    engine.draw_debug_line(from, to, false, 0.08, 0xFF00FF); // Magenta path
                }
            }
        }

        // Auto-play functionality
        if (settings.is_playing) {
            if (engine.frame_idx % 15 === 0) {
                settings.step += 1;
                if (settings.step >= all_steps.length) {
                    settings.step = 0;
                    actions.compute_all_steps(); // Restart
                }
            }
        }

        refresh_displays(gui);
    });

</script>
</body>
</html>